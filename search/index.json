[{"content":"2022年3月15号，Go 1.18版本正式发布，泛型也在这个版本中被支持。\n下面简单的学习了下Go的泛型使用：\n基本使用 首先从最常用的max函数来看。 假设我现在需要两个int类型的最大值，原先的Go写法是：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(maxInt(32, 64)) } func maxInt(a, b int) int { if a \u0026gt; b { return a } return b } 这个时候我需要增加一个获取float64的最大值，那么我们就要新增一个函数叫maxFloat64：\nfunc maxFloat64(a, b float64) float64 { if a \u0026gt; b { return a } return b } 每当我们需要对一种类型进行比较的时候，我们都需要重新编写一个函数，尽管他们的逻辑其实都是一样的，将来甚至还需要int8、int16、int32等等的类型。\n当引入泛型之后，我们可以写成：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(max(1, 2)) fmt.Println(max[int32](1, 2)) fmt.Println(max(1.5, 2.3)) } func max[T int | int8 | int16 | int32 | int64 | float32 | float64](a, b T) T { if a \u0026gt; b { return a } return b } 当然，后面跟了一长串的int｜int8、、、这样实在有点费劲，如果我们之后需要增加一个min函数呢，岂不是又要把上面的这些抄一遍吗，所以这里还可以用interface提前定义下：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(max(1, 2)) fmt.Println(max[int32](1, 2)) fmt.Println(max(1.5, 2.3)) fmt.Println(min(1, 2)) fmt.Println(min[int32](1, 2)) fmt.Println(min(1.5, 2.3)) } type Number interface { int | int8 | int16 | int32 | int64 | float32 | float64 } func max[T Number](a, b T) T { if a \u0026gt; b { return a } return b } func min[T Number](a, b T) T { if a \u0026lt; b { return a } return b } 在结构体中使用泛型 除了函数声明中可以使用泛型，结构体中一样可以使用：\npackage main import ( \u0026#34;fmt\u0026#34; ) type Data[T comparable] struct { Message T } func (d Data[T]) Print() { fmt.Println(d.Message) } func main() { d := Data[int]{ Message: 66, } d.Print() } 这里有个类型：comparable\n可以看看go的源码里面写的：\n// comparable is an interface that is implemented by all comparable types // (booleans, numbers, strings, pointers, channels, arrays of comparable types, // structs whose fields are all comparable types). // The comparable interface may only be used as a type parameter constraint, // not as the type of a variable. type comparable interface{ comparable } 大概意思就是允许booleans, numbers, strings, pointers, channels, comparable类型组成的arrays以及所有字段都是由comparable类型组成的struct。\n这里也有一个any类型：\n// any is an alias for interface{} and is equivalent to interface{} in all ways. type any = interface{} 其实就是interface{}的别称。\n与interface{}性能对比 在没有泛型的时候，我们想要通常使用interface{}和断言来模拟泛型操作，比如我们构建一个简单的KV内存缓存：\ntype Message struct { message string } func NewStore() *Store { return \u0026amp;Store{ data: make(map[string]interface{}), } } type Store struct { data map[string]interface{} } func (s *Store) Get(k string) (interface{}, bool) { d, ok := s.data[k] return d, ok } func (s *Store) Set(k string, v interface{}) { s.data[k] = v } func (s *Store) Del(k string) { delete(s.data, k) } 这里我们定义的需要存储的类型为Message， 我们需要在内部使用一个map[string]interface{}来存放数据\n对应的插入、查找以及删除操作为：\ns.Set(\u0026#34;test\u0026#34;, \u0026amp;Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d.(Message) s.Del(\u0026#34;test\u0026#34;) 因为没有泛型，所以每次通过Get获取到的数据都需要进行一次断言，转换为我们期望的类型。\n当有了泛型之后，一切都变得简单了，我们不在需要断言，代码编程：\ntype TStore[K comparable, V any] struct { data map[K]V } func NewTStore[K comparable, V any]() *TStore[K, V] { return \u0026amp;TStore[K, V]{ data: make(map[K]V), } } func (s *TStore[K, V]) Get(k K) (V, bool) { d, ok := s.data[k] return d, ok } func (s *TStore[K, V]) Set(k K, v V) { s.data[k] = v } func (s *TStore[K, V]) Del(k K) { delete(s.data, k) } 这里用于存储数据的map变为通过泛型来实现，所以对应的操作简化为：\ns.Set(\u0026#34;test\u0026#34;, Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d s.Del(\u0026#34;test\u0026#34;) 与使用interface{}方法实现的相比，泛型的版本可以直接使用Get到的数据，而不用执行断言。\n下面我们可以跑下benchmark来看看两者的差别：\ngoos: linux goarch: amd64 pkg: generics cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics BenchmarkGenerice-8 32675426 35.01 ns/op 0 B/op 0 allocs/op BenchmarkInterface-8 17569459 67.05 ns/op 16 B/op 1 allocs/op PASS coverage: 0.0% of statements ok generics 2.433s interface {}实现的版本比泛型实现的版本的性能差一倍！\n下面贴上测试的完整代码：\npackage main import ( \u0026#34;testing\u0026#34; ) type TStore[K comparable, V any] struct { data map[K]V } func NewTStore[K comparable, V any]() *TStore[K, V] { return \u0026amp;TStore[K, V]{ data: make(map[K]V), } } func (s *TStore[K, V]) Get(k K) (V, bool) { d, ok := s.data[k] return d, ok } func (s *TStore[K, V]) Set(k K, v V) { s.data[k] = v } func (s *TStore[K, V]) Del(k K) { delete(s.data, k) } type Message struct { message string } func NewStore() *Store { return \u0026amp;Store{ data: make(map[string]interface{}), } } type Store struct { data map[string]interface{} } func (s *Store) Get(k string) (interface{}, bool) { d, ok := s.data[k] return d, ok } func (s *Store) Set(k string, v interface{}) { s.data[k] = v } func (s *Store) Del(k string) { delete(s.data, k) } func testT(s *TStore[string, Message]) { s.Set(\u0026#34;test\u0026#34;, Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d s.Del(\u0026#34;test\u0026#34;) } func BenchmarkGenerice(b *testing.B) { t := NewTStore[string, Message]() for n := 0; n \u0026lt; b.N; n++ { testT(t) // run fib(30) b.N times  } } func test(s *Store) { s.Set(\u0026#34;test\u0026#34;, Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d.(Message) s.Del(\u0026#34;test\u0026#34;) } func BenchmarkInterface(b *testing.B) { t := NewStore() for n := 0; n \u0026lt; b.N; n++ { test(t) // run fib(30) b.N times  } } 强烈推荐大家升级到新版Go，体验下泛型。\n","date":"2022-03-17T11:42:12+08:00","permalink":"/p/go-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/","title":"Go 泛型使用与性能对比"},{"content":"当加载配置的时候，我们通常会将配置设置一个默认值，但是通常默认值不是Go中的空值，比如 服务的端口号：\ntype ServerConfig struct{ Port uint } func main(){ conf:=loadConfig() if conf.ServerConfig.Port==0{ conf.ServerConfig.Port = 8080 } } 每次有一个值我们都需要增加一个if语句进行判断，当一个配置有很多的时候，初始化写起来可能就非常的繁琐。\n幸运的是Go中提供了tag，我们可以借用tag，结合反射来实现默认值。\n原理比较简单大概流程就是：\n 通过反射解析当前的结构体 查看当前字段的值时候为空值 如果为空，读取tag中的default，并初始化 不为空直接略过  具体代码可以参考：https://github.com/zzjcool/goutils/blob/main/defaults/defauls.go\n这里给出使用方法：\nDefaults Enforce default values on struct fields.\ntype User struct { Name string `default:\u0026#34;Goku\u0026#34;` Power float64 `default:\u0026#34;9000.01\u0026#34;` } var u User err := defaults.Apply(\u0026amp;u) if err != nil { log.Fatal(\u0026#34;Uh oh: %v\u0026#34;, err) } fmt.Print(u.Name) // Goku fmt.Print(u.Power) // 9000.01 Defaults are only applied to fields at their zero value.\ntype Config struct { Host *string `default:\u0026#34;0.0.0.0\u0026#34;` Port *int `default:\u0026#34;8000\u0026#34;` } var cfg Config json.Unmarshal([]byte(`{Host: \u0026#34;charm.sh\u0026#34;}`), \u0026amp;cfg) if err := defaults.Apply(\u0026amp;cfg); err != nil { log.Fatal(\u0026#34;Rats: %v\u0026#34;, err) } fmt.Print(cfg.Host) // charm.sh fmt.Print(cfg.Port) // 8000 Works well with JSON, Yaml, and so on.\ntype Config struct { Host string `json:\u0026#34;host\u0026#34; default:\u0026#34;0.0.0.0\u0026#34;` Port int `json:\u0026#34;port\u0026#34; default:\u0026#34;8000\u0026#34;` Debug bool `json:\u0026#34;debug\u0026#34; default:\u0026#34;true\u0026#34;` } Supported Types The following types are supported:\n string bool int int8 int16 int32 (and rune, with some caveats) int64 uint uint8 uint16 uint32 uint64 float32 float64 []byte/[]uint8  …as well as pointers to those types.\nEmbedded Structs Embedded structs are supported. The following will parse as expected:\ntype GroceryList struct { Fruit struct { Bananas int `default:\u0026#34;8\u0026#34;` Pears int `default:\u0026#34;12\u0026#34;` } Vegetables *struct { Artichokes int `default:\u0026#34;4\u0026#34;` SweetPotatoes int `default:\u0026#34;16\u0026#34;` } } Embedded structs do not need a default tag in order to be parsed. Embedded structs that are nil will be initialized with their zero value so they can be parsed accoringly.\nRunes and Int32s In Go rune is just an alias for int32. This presents some ambiguity when parsing default values. For example, should \u0026quot;1\u0026quot; be parsed as a literal 1 or as a unicode '1' (which has the int32 value of 49)?\nBecause of this ambiguity we recommend avoiding setting defaults on runes. That said, this package defaults to parsing int32 as integers. Failing that, it tries to parse them as a rune.\n// This works as expected... type Cool struct { Fave32BitInteger int32 `default:\u0026#34;12\u0026#34;` FaveChar rune `default:\u0026#34;a\u0026#34;` } // ...but these will not. type UhOh struct { FaveChar rune `default:\u0026#34;3\u0026#34;` // this is a unicode ETX or ctrl+c  FaveChar rune `default:\u0026#34;97\u0026#34;` // this is a unicode `a` } 这个package本来是： github.com/charmbracelet/defaults 但是原地址无法访问\n","date":"2022-03-15T23:41:23+08:00","permalink":"/p/go-struct-%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"Go Struct 默认值的实现"},{"content":"Go的groutine使用起来十分的方便，可以帮助开发者快速的实现支持并行的程序，但是并行的程序往往需要根据用户的不同需求进行调度，比较常用的有sync.WaitGroup，通常是用于等待多个groutine执行完毕后继续后续的任务。\n但是有时候我们需要多个groutine并行执行后同时等待一个条件满足后再继续执行后续任务，例如之前写的Reduce库提给阻塞的Add方法，当所有的数据flush后所有的Add都停止阻塞，这种行为类似于学校考试，在开考前所有同学提前到考场等待考试开始，考试的开始时间都是统一的，当考试时间到了，广播打铃，所有同学收到信号，开始考试。当然这个时候有同学迟到了，那么因为考试已经开始，他就可以直接进入考场开始考试。\n需求说明 需要一个Wait接口，当调用的时候，如果条件未满足，将阻塞，同时调用Done接口的表示条件已经满足，解除所有Wait的阻塞，Wait可以被多个groutine调用，多个Wait接口对应一个Done。\n如果发生错误，那么错误将通知给所有的Wait的groutine，\n接口设计 为了实现上述的需求，我们设计对应的接口：\ntype Interface interface { // Wait 可以阻塞当前Groutine，直到Done被调用，可以获取到Done传入的error  Wait() error // Done 解除所有Wait的阻塞，如果发生错误，将error传入  Done(err error) } 实现细节 需要实现以上的需求，可以想到的方式有两种，一种是使用sync.WaitGroup，还有一种是使用sync.Cond。同时，根据这个组件的特性，我们把这个库取名为castwait\nsync.WaitGroup 实现方式 使用sync.WaitGroup实现起来比较简单，调用Add后，使用Wait后可以产生阻塞。\n设计，对应的结构体，为：\ntype castWait struct { wg sync.WaitGroup err error // 保存调用的错误 } 对应的接口实现为：\n// Wait 阻塞等待完成 func (c *castWait) Wait() error { c.wg.Wait() return c.err } // Done 完成 func (c *castWait) Done(err error) { c.err = err c.wg.Done() } sync.Cond 实现方式 sync.Cond包使用的比较少，具体的Cond包的使用可以参考：https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/，下次有时间再补充下sync.Cond的使用。\n结构的设计与接口的实现：\ntype condImpl struct { done bool C *sync.Cond err error } // Wait 阻塞等待完成 func (c *condImpl) Wait() error { c.C.L.Lock() defer c.C.L.Unlock() for !c.done { c.C.Wait() } return c.err } // Done 完成 func (c *condImpl) Done(err error) { c.err = err c.C.L.Lock() c.done = true c.C.L.Unlock() c.C.Broadcast() } 使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/castWait\u0026#34; // ) n := 100000 c := New() wg := sync.WaitGroup{} wg.Add(n) for i := 0; i \u0026lt; n; i += 1 { go func() { err := c.Wait() if err!=nil{ // do ... } wg.Done() }() } c.Done(exErr) wg.Wait() 仓库地址 https://github.com/zzjcool/goutils/tree/main/castwait\n","date":"2022-02-27T16:19:01+08:00","permalink":"/p/go%E5%8D%8F%E7%A8%8B%E5%AF%B9%E9%BD%90%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8Ccastwait%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"Go协程对齐，等待条件执行，Castwait库实现"},{"content":"在业务中我们可能经常会遇到某个接口需要高频的调用，例如数据库更新、插入操作，调用某api，在这里每一次的调用都会有额外的成本，所以无论是数据库还是一些api调用接口，都提供了批量操作的方式，通过批量操作来降低开销，提升效率。\n有的旧代码，或者业务本身不支持批量操作，所以我们需要对相关的数据进行聚合，转换为批量操作，个人认为这种操作有点类似于MapReduce操作中的Reduce，所以暂且称之为Reduce吧。\n需求 提供一个缓存，每次将单次的操作加入到这个缓存中，之后一次性从缓存中取出所有的数据，进行批量操作。\n当然何时将缓存全部取出来并进行操作也是个问题，所以我们希望可以传入两个值：\n maxSize:表示缓存的最大大小 refreshMillisecond:表示缓存刷新的最短周期  也就是可以有两个条件可以触发批量操作，一个是固定时间，一个是达到缓存上限。\n为了模拟原来单次操作产生的阻塞，所以也应当支持阻塞，当该批所有的数据被批量处理完成后，代码可以执行下一步逻辑。\n同时应当可以捕获返回的错误，便于后续的处理。\n接口设计 type ReduceWait interface { Wait() error } type Interface interface { Add(data interface{}) ReduceWait Destroy() } 对于Reduce核心操作就是Add，其作用就是将数据插入到cache中，之后返回个ReduceWait接口。\nReduceWait接口只有一个方法Wait() error，当插入数据后，可以调用这个方法产生阻塞，等待到内部的数据被消费后将返回error类型。\n实现细节 具体实现部分主要是交由ReduceImple结构体来实现。除了实现Interface的接口的方法外，还有：\n daemon：负责定时处理cache中积压的数据 refresh 刷新cache中所有的数据，将数据进行批量消费  在refresh的时候应当对Add操作上锁，保证同一时间只有一个refresh，或者Add在执行。\n同时比较麻烦的地方是调用Add的时候可能会因为Cache满了调用refresh，调用refresh的时候要保证没有其他的Add改变cache，所以Add需要一把锁 而refresh需要一把读写锁，其中refresh的读锁给Add。\nAdd返回的Wait我们使用casewait实现，每次refresh将原来的阻塞接触，开启新的casewait即可。\n在初始化的时候需要传入一个HandleFunc，这个函数的签名为type HandleFunc func(datas []interface{}) error 会在每一次的refresh操作中被调用，这里返回的error会被上抛到wait返回。\n使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/reduce\u0026#34; // ) // refresh调用的函数  doFunc := func(datas []interface{}) error { fmt.Println(len(datas)) return nil } // 创建一个reduce，300ms刷新一次，同时最大容量是100  rdc := reduce.New(doFunc, 300, 100) // 加入一个数据，同时同步等待完成，如果不调用就是异步操作  err := rdc.Add(\u0026#34;test\u0026#34;).Wait() if err != nil { fmt.Println(err) } 仓库地址 https://github.com/zzjcool/goutils/tree/main/reduce\n","date":"2022-02-20T18:04:30+08:00","permalink":"/p/%E4%B8%9A%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96reduce%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"业务性能优化，Reduce库实现"},{"content":"材料准备  主料  辣椒 猪肉   辅料  小米椒 玉米淀粉 油 糖 盐 生抽 老抽 鸡精 大蒜    准备工作  将猪肉切成丝，加入少量老抽和生抽，玉米淀粉腌制，使用淀粉腌制过的猪肉会更加的嫩，腌制十分钟左右就可以。 辣椒切开，掏出辣椒籽，放一旁备用，根据自己喜好可以加入适量来额小米椒。 大蒜切粒。  制作流程  热锅，加入食用油，等待油热。 将腌制的猪肉倒入锅中，大火翻炒，炒至变色后关火。 将肉倒出，放一旁备用。 剩下的油继续开火，放入大蒜。 等待有香味后加入辣椒翻炒。 炒一会后倒入之前的肉，加少量的糖。 加入适量的鸡精、盐、生抽以及少量老抽提色。 翻炒后出锅  成品总结  辣椒炒肉 \n第一次炒，肉放的太多了（主要还是盒马上买的一份辣椒份量实在是太少了），然后上海这里的辣椒都不是很辣，即使加入了小米椒，辣度还是有限。\n总体来说味道还是很不错的，从小最喜欢的一道菜。\n","date":"2022-02-15T12:06:06+08:00","image":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/ljcr_hu5ecfe790bedc4bd537f2edf54cfd5a05_316058_120x120_fill_q75_box_smart1.jpg","permalink":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/","title":"辣椒炒肉"},{"content":"Docker启动Nginx 可以使用docker-compose快速的启动Nginx docker-compose.yaml文件：\nversion:\u0026#39;3\u0026#39;services:nginx:image:nginxcontainer_name:nginxnetwork_mode:\u0026#34;host\u0026#34;volumes:- ./nginx:/etc/nginx/conf.drestart:unless-stopped可以在当前目录下的nginx目录添加任意配置\nNginx 反向代理Websocket server { listen 48265; server_name \u0026#34;\u0026#34;; location / { proxy_pass http://domain:48265; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } 最后一行配置可以转发ws\n有时候我们的nginx反向代理会出错，但是我们检查发现上游服务器是正常的，那这可能 是因为反向代理后端发生dns解析的变动（如k8s服务重启或者ddns），所以 需要配置nginx的dns解析（resolver 8.8.8.8），同时反向代理的后端地址需要写为变量：\nserver { listen 48265; server_name \u0026#34;\u0026#34;; resolver 119.29.29.29 8.8.8.8 valid=30s; set $proxy_pass_url http://domain:48265; location / { proxy_pass $proxy_pass_url; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } Nginx 直接显示系统目录 server { listen 8880; listen [::]:8880; server_name domain.com; location / { root /data; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8,gbk; } } 其中root /data表示实际的目录位置\n","date":"2022-01-07T10:33:38+08:00","permalink":"/p/nginx-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","title":"Nginx 相关配置"},{"content":"net/url 添加query 原本有url:http://domain.com, 现在想要添加query参数变成:http://domain.com?key=value\n可以自己写一个方法去添加query参数。\nfunc TestURL(t *testing.T) { api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) if err != nil { t.Fatal(err) } URLAddQuery(api, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) fmt.Println(api.String()) } // URLAddQuery 提供一个URL，然后添加query参数 func URLAddQuery(addr *url.URL, key, value string) { query := addr.Query() query.Add(key, value) addr.RawQuery = query.Encode() } url拼接path api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) api.Path = \u0026#34;/api/test\u0026#34; ","date":"2022-01-04T19:43:41+08:00","permalink":"/p/golang-%E5%86%85%E7%BD%AE%E5%8C%85%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","title":"Golang 内置包常用方法"}]