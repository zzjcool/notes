[{"content":"在业务中我们可能经常会遇到某个接口需要高频的调用，例如数据库更新、插入操作，调用某api，在这里每一次的调用都会有额外的成本，所以无论是数据库还是一些api调用接口，都提供了批量操作的方式，通过批量操作来降低开销，提升效率。\n有的旧代码，或者业务本身不支持批量操作，所以我们需要对相关的数据进行聚合，转换为批量操作，个人认为这种操作有点类似于MapReduce操作中的Reduce，所以暂且称之为Reduce吧。\n需求 提供一个缓存，每次将单次的操作加入到这个缓存中，之后一次性从缓存中取出所有的数据，进行批量操作。\n当然何时将缓存全部取出来并进行操作也是个问题，所以我们希望可以传入两个值：\n maxSize:表示缓存的最大大小 refreshMillisecond:表示缓存刷新的最短周期  也就是可以有两个条件可以触发批量操作，一个是固定时间，一个是达到缓存上限。\n为了模拟原来单次操作产生的阻塞，所以也应当支持阻塞，当该批所有的数据被批量处理完成后，代码可以执行下一步逻辑。\n同时应当可以捕获返回的错误，便于后续的处理。\n接口设计 type ReduceWait interface { Wait() error } type Interface interface { Add(data interface{}) ReduceWait Destroy() } 对于Reduce核心操作就是Add，其作用就是将数据插入到cache中，之后返回个ReduceWait接口。\nReduceWait接口只有一个方法Wait() error，当插入数据后，可以调用这个方法产生阻塞，等待到内部的数据被消费后将返回error类型。\n实现细节 具体实现部分主要是交由ReduceImple结构体来实现。除了实现Interface的接口的方法外，还有：\n daemon：负责定时处理cache中积压的数据 refresh 刷新cache中所有的数据，将数据进行批量消费  在refresh的时候应当对Add操作上锁，保证同一时间只有一个refresh，或者Add在执行。\n同时比较麻烦的地方是调用Add的时候可能会因为Cache满了调用refresh，调用refresh的时候要保证没有其他的Add改变cache，所以Add需要一把锁 而refresh需要一把读写锁，其中refresh的读锁给Add。\nAdd返回的Wait我们使用casewait实现，每次refresh将原来的阻塞接触，开启新的casewait即可。\n在初始化的时候需要传入一个HandleFunc，这个函数的签名为type HandleFunc func(datas []interface{}) error 会在每一次的refresh操作中被调用，这里返回的error会被上抛到wait返回。\n使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/reduce\u0026#34; // ) // refresh调用的函数  doFunc := func(datas []interface{}) error { fmt.Println(len(datas)) return nil } // 创建一个reduce，300ms刷新一次，同时最大容量是100  rdc := reduce.New(doFunc, 300, 100) // 加入一个数据，同时同步等待完成，如果不调用就是异步操作  err := rdc.Add(\u0026#34;test\u0026#34;).Wait() if err != nil { fmt.Println(err) } 仓库地址 https://github.com/zzjcool/goutils/tree/main/reduce\n","date":"2022-02-20T18:04:30+08:00","permalink":"/p/%E4%B8%9A%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96reduce%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"业务性能优化，Reduce库实现"},{"content":"材料准备  主料  辣椒 猪肉   辅料  小米椒 玉米淀粉 油 糖 盐 生抽 老抽 鸡精 大蒜    准备工作  将猪肉切成丝，加入少量老抽和生抽，玉米淀粉腌制，使用淀粉腌制过的猪肉会更加的嫩，腌制十分钟左右就可以。 辣椒切开，掏出辣椒籽，放一旁备用，根据自己喜好可以加入适量来额小米椒。 大蒜切粒。  制作流程  热锅，加入食用油，等待油热。 将腌制的猪肉倒入锅中，大火翻炒，炒至变色后关火。 将肉倒出，放一旁备用。 剩下的油继续开火，放入大蒜。 等待有香味后加入辣椒翻炒。 炒一会后倒入之前的肉，加少量的糖。 加入适量的鸡精、盐、生抽以及少量老抽提色。 翻炒后出锅  成品总结  辣椒炒肉 \n第一次炒，肉放的太多了（主要还是盒马上买的一份辣椒份量实在是太少了），然后上海这里的辣椒都不是很辣，即使加入了小米椒，辣度还是有限。\n总体来说味道还是很不错的，从小最喜欢的一道菜。\n","date":"2022-02-15T12:06:06+08:00","image":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/ljcr_hu5ecfe790bedc4bd537f2edf54cfd5a05_316058_120x120_fill_q75_box_smart1.jpg","permalink":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/","title":"辣椒炒肉"},{"content":"Docker启动Nginx 可以使用docker-compose快速的启动Nginx docker-compose.yaml文件：\nversion:\u0026#39;3\u0026#39;services:nginx:image:nginxcontainer_name:nginxnetwork_mode:\u0026#34;host\u0026#34;volumes:- ./nginx:/etc/nginx/conf.drestart:unless-stopped可以在当前目录下的nginx目录添加任意配置\nNginx 反向代理Websocket server { listen 48265; server_name \u0026#34;\u0026#34;; location / { proxy_pass http://domain:48265; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } 最后一行配置可以转发ws\n有时候我们的nginx反向代理会出错，但是我们检查发现上游服务器是正常的，那这可能 是因为反向代理后端发生dns解析的变动（如k8s服务重启或者ddns），所以 需要配置nginx的dns解析（resolver 8.8.8.8），同时反向代理的后端地址需要写为变量：\nserver { listen 48265; server_name \u0026#34;\u0026#34;; resolver 119.29.29.29 8.8.8.8 valid=30s; set $proxy_pass_url http://domain:48265; location / { proxy_pass $proxy_pass_url; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } Nginx 直接显示系统目录 server { listen 8880; listen [::]:8880; server_name domain.com; location / { root /data; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8,gbk; } } 其中root /data表示实际的目录位置\n","date":"2022-01-07T10:33:38+08:00","permalink":"/p/nginx-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","title":"Nginx 相关配置"},{"content":"net/url 添加query 原本有url:http://domain.com, 现在想要添加query参数变成:http://domain.com?key=value\n可以自己写一个方法去添加query参数。\nfunc TestURL(t *testing.T) { api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) if err != nil { t.Fatal(err) } URLAddQuery(api, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) fmt.Println(api.String()) } // URLAddQuery 提供一个URL，然后添加query参数 func URLAddQuery(addr *url.URL, key, value string) { query := addr.Query() query.Add(key, value) addr.RawQuery = query.Encode() } url拼接path api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) api.Path = \u0026#34;/api/test\u0026#34; ","date":"2022-01-04T19:43:41+08:00","permalink":"/p/golang-%E5%86%85%E7%BD%AE%E5%8C%85%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","title":"Golang 内置包常用方法"}]