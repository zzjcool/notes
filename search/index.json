[{"content":"Go的groutine使用起来十分的方便，可以帮助开发者快速的实现支持并行的程序，但是并行的程序往往需要根据用户的不同需求进行调度，比较常用的有sync.WaitGroup，通常是用于等待多个groutine执行完毕后继续后续的任务。\n但是有时候我们需要多个groutine并行执行后同时等待一个条件满足后再继续执行后续任务，例如之前写的Reduce库提给阻塞的Add方法，当所有的数据flush后所有的Add都停止阻塞，这种行为类似于学校考试，在开考前所有同学提前到考场等待考试开始，考试的开始时间都是统一的，当考试时间到了，广播打铃，所有同学收到信号，开始考试。当然这个时候有同学迟到了，那么因为考试已经开始，他就可以直接进入考场开始考试。\n需求说明 需要一个Wait接口，当调用的时候，如果条件未满足，将阻塞，同时调用Done接口的表示条件已经满足，解除所有Wait的阻塞，Wait可以被多个groutine调用，多个Wait接口对应一个Done。\n如果发生错误，那么错误将通知给所有的Wait的groutine，\n接口设计 为了实现上述的需求，我们设计对应的接口：\ntype Interface interface { // Wait 可以阻塞当前Groutine，直到Done被调用，可以获取到Done传入的error  Wait() error // Done 解除所有Wait的阻塞，如果发生错误，将error传入  Done(err error) } 实现细节 需要实现以上的需求，可以想到的方式有两种，一种是使用sync.WaitGroup，还有一种是使用sync.Cond。同时，根据这个组件的特性，我们把这个库取名为castwait\nsync.WaitGroup 实现方式 使用sync.WaitGroup实现起来比较简单，调用Add后，使用Wait后可以产生阻塞。\n设计，对应的结构体，为：\ntype castWait struct { wg sync.WaitGroup err error // 保存调用的错误 } 对应的接口实现为：\n// Wait 阻塞等待完成 func (c *castWait) Wait() error { c.wg.Wait() return c.err } // Done 完成 func (c *castWait) Done(err error) { c.err = err c.wg.Done() } sync.Cond 实现方式 sync.Cond包使用的比较少，具体的Cond包的使用可以参考：https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/，下次有时间再补充下sync.Cond的使用。\n结构的设计与接口的实现：\ntype condImpl struct { done bool C *sync.Cond err error } // Wait 阻塞等待完成 func (c *condImpl) Wait() error { c.C.L.Lock() defer c.C.L.Unlock() for !c.done { c.C.Wait() } return c.err } // Done 完成 func (c *condImpl) Done(err error) { c.err = err c.C.L.Lock() c.done = true c.C.L.Unlock() c.C.Broadcast() } 使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/castWait\u0026#34; // ) n := 100000 c := New() wg := sync.WaitGroup{} wg.Add(n) for i := 0; i \u0026lt; n; i += 1 { go func() { err := c.Wait() if err!=nil{ // do ... } wg.Done() }() } c.Done(exErr) wg.Wait() 仓库地址 https://github.com/zzjcool/goutils/tree/main/castwait\n","date":"2022-02-27T16:19:01+08:00","permalink":"/p/go%E5%8D%8F%E7%A8%8B%E5%AF%B9%E9%BD%90%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8Ccastwait%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"Go协程对齐，等待条件执行，Castwait库实现"},{"content":"在业务中我们可能经常会遇到某个接口需要高频的调用，例如数据库更新、插入操作，调用某api，在这里每一次的调用都会有额外的成本，所以无论是数据库还是一些api调用接口，都提供了批量操作的方式，通过批量操作来降低开销，提升效率。\n有的旧代码，或者业务本身不支持批量操作，所以我们需要对相关的数据进行聚合，转换为批量操作，个人认为这种操作有点类似于MapReduce操作中的Reduce，所以暂且称之为Reduce吧。\n需求 提供一个缓存，每次将单次的操作加入到这个缓存中，之后一次性从缓存中取出所有的数据，进行批量操作。\n当然何时将缓存全部取出来并进行操作也是个问题，所以我们希望可以传入两个值：\n maxSize:表示缓存的最大大小 refreshMillisecond:表示缓存刷新的最短周期  也就是可以有两个条件可以触发批量操作，一个是固定时间，一个是达到缓存上限。\n为了模拟原来单次操作产生的阻塞，所以也应当支持阻塞，当该批所有的数据被批量处理完成后，代码可以执行下一步逻辑。\n同时应当可以捕获返回的错误，便于后续的处理。\n接口设计 type ReduceWait interface { Wait() error } type Interface interface { Add(data interface{}) ReduceWait Destroy() } 对于Reduce核心操作就是Add，其作用就是将数据插入到cache中，之后返回个ReduceWait接口。\nReduceWait接口只有一个方法Wait() error，当插入数据后，可以调用这个方法产生阻塞，等待到内部的数据被消费后将返回error类型。\n实现细节 具体实现部分主要是交由ReduceImple结构体来实现。除了实现Interface的接口的方法外，还有：\n daemon：负责定时处理cache中积压的数据 refresh 刷新cache中所有的数据，将数据进行批量消费  在refresh的时候应当对Add操作上锁，保证同一时间只有一个refresh，或者Add在执行。\n同时比较麻烦的地方是调用Add的时候可能会因为Cache满了调用refresh，调用refresh的时候要保证没有其他的Add改变cache，所以Add需要一把锁 而refresh需要一把读写锁，其中refresh的读锁给Add。\nAdd返回的Wait我们使用casewait实现，每次refresh将原来的阻塞接触，开启新的casewait即可。\n在初始化的时候需要传入一个HandleFunc，这个函数的签名为type HandleFunc func(datas []interface{}) error 会在每一次的refresh操作中被调用，这里返回的error会被上抛到wait返回。\n使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/reduce\u0026#34; // ) // refresh调用的函数  doFunc := func(datas []interface{}) error { fmt.Println(len(datas)) return nil } // 创建一个reduce，300ms刷新一次，同时最大容量是100  rdc := reduce.New(doFunc, 300, 100) // 加入一个数据，同时同步等待完成，如果不调用就是异步操作  err := rdc.Add(\u0026#34;test\u0026#34;).Wait() if err != nil { fmt.Println(err) } 仓库地址 https://github.com/zzjcool/goutils/tree/main/reduce\n","date":"2022-02-20T18:04:30+08:00","permalink":"/p/%E4%B8%9A%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96reduce%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"业务性能优化，Reduce库实现"},{"content":"材料准备  主料  辣椒 猪肉   辅料  小米椒 玉米淀粉 油 糖 盐 生抽 老抽 鸡精 大蒜    准备工作  将猪肉切成丝，加入少量老抽和生抽，玉米淀粉腌制，使用淀粉腌制过的猪肉会更加的嫩，腌制十分钟左右就可以。 辣椒切开，掏出辣椒籽，放一旁备用，根据自己喜好可以加入适量来额小米椒。 大蒜切粒。  制作流程  热锅，加入食用油，等待油热。 将腌制的猪肉倒入锅中，大火翻炒，炒至变色后关火。 将肉倒出，放一旁备用。 剩下的油继续开火，放入大蒜。 等待有香味后加入辣椒翻炒。 炒一会后倒入之前的肉，加少量的糖。 加入适量的鸡精、盐、生抽以及少量老抽提色。 翻炒后出锅  成品总结  辣椒炒肉 \n第一次炒，肉放的太多了（主要还是盒马上买的一份辣椒份量实在是太少了），然后上海这里的辣椒都不是很辣，即使加入了小米椒，辣度还是有限。\n总体来说味道还是很不错的，从小最喜欢的一道菜。\n","date":"2022-02-15T12:06:06+08:00","image":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/ljcr_hu5ecfe790bedc4bd537f2edf54cfd5a05_316058_120x120_fill_q75_box_smart1.jpg","permalink":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/","title":"辣椒炒肉"},{"content":"Docker启动Nginx 可以使用docker-compose快速的启动Nginx docker-compose.yaml文件：\nversion:\u0026#39;3\u0026#39;services:nginx:image:nginxcontainer_name:nginxnetwork_mode:\u0026#34;host\u0026#34;volumes:- ./nginx:/etc/nginx/conf.drestart:unless-stopped可以在当前目录下的nginx目录添加任意配置\nNginx 反向代理Websocket server { listen 48265; server_name \u0026#34;\u0026#34;; location / { proxy_pass http://domain:48265; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } 最后一行配置可以转发ws\n有时候我们的nginx反向代理会出错，但是我们检查发现上游服务器是正常的，那这可能 是因为反向代理后端发生dns解析的变动（如k8s服务重启或者ddns），所以 需要配置nginx的dns解析（resolver 8.8.8.8），同时反向代理的后端地址需要写为变量：\nserver { listen 48265; server_name \u0026#34;\u0026#34;; resolver 119.29.29.29 8.8.8.8 valid=30s; set $proxy_pass_url http://domain:48265; location / { proxy_pass $proxy_pass_url; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } Nginx 直接显示系统目录 server { listen 8880; listen [::]:8880; server_name domain.com; location / { root /data; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8,gbk; } } 其中root /data表示实际的目录位置\n","date":"2022-01-07T10:33:38+08:00","permalink":"/p/nginx-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","title":"Nginx 相关配置"},{"content":"net/url 添加query 原本有url:http://domain.com, 现在想要添加query参数变成:http://domain.com?key=value\n可以自己写一个方法去添加query参数。\nfunc TestURL(t *testing.T) { api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) if err != nil { t.Fatal(err) } URLAddQuery(api, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) fmt.Println(api.String()) } // URLAddQuery 提供一个URL，然后添加query参数 func URLAddQuery(addr *url.URL, key, value string) { query := addr.Query() query.Add(key, value) addr.RawQuery = query.Encode() } url拼接path api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) api.Path = \u0026#34;/api/test\u0026#34; ","date":"2022-01-04T19:43:41+08:00","permalink":"/p/golang-%E5%86%85%E7%BD%AE%E5%8C%85%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","title":"Golang 内置包常用方法"}]