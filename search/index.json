[{"content":"Go标准库 - container包与sort包 sort包 sort包提供了用于对切片和用户定义的集合进行排序的功能。它支持对基本数据类型和用户自定义集合的排序。\n结构和方法 // 基础接口 type Interface interface { Len() int // 集合中的元素数量 Less(i, j int) bool // 第i个元素是否应排在第j个元素前面 Swap(i, j int) // 交换第i个和第j个元素 } // 主要函数 func Sort(data Interface) // 对数据进行排序 func Stable(data Interface) // 稳定排序 func IsSorted(data Interface) bool // 判断是否已经排序 func Reverse(data Interface) Interface // 返回逆序排序的包装器 func Search(n int, f func(int) bool) int // 二分查找 // 切片排序 func Slice(x any, less func(i, j int) bool) // 使用less函数对切片进行排序 func SliceStable(x any, less func(i, j int) bool) // 稳定排序版本 func SliceIsSorted(x any, less func(i, j int) bool) bool // 判断切片是否已排序 // 基本类型切片排序 func Float64s(x []float64) // 浮点数切片排序 func Float64sAreSorted(x []float64) bool // 判断浮点数切片是否已排序 func Ints(x []int) // 整数切片排序 func IntsAreSorted(x []int) bool // 判断整数切片是否已排序 func Strings(x []string) // 字符串切片排序 func StringsAreSorted(x []string) bool // 判断字符串切片是否已排序 使用示例 基本排序（使用 sort.Slice）： package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func main() { people := []struct { Name string Age int }{ {\u0026#34;Bob\u0026#34;, 31}, {\u0026#34;John\u0026#34;, 42}, {\u0026#34;Michael\u0026#34;, 17}, {\u0026#34;Jenny\u0026#34;, 26}, } // 使用 sort.Slice 进行排序 sort.Slice(people, func(i, j int) bool { return people[i].Age \u0026lt; people[j].Age }) fmt.Println(\u0026#34;按年龄升序:\u0026#34;, people) // 反向排序 sort.Slice(people, func(i, j int) bool { return people[i].Age \u0026gt; people[j].Age }) fmt.Println(\u0026#34;按年龄降序:\u0026#34;, people) } 实现 sort.Interface（传统方式）： type Person struct { Name string Age int } // ByAge 实现 sort.Interface type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u0026lt; a[j].Age } func main() { people := []Person{ {\u0026#34;Bob\u0026#34;, 31}, {\u0026#34;John\u0026#34;, 42}, {\u0026#34;Michael\u0026#34;, 17}, {\u0026#34;Jenny\u0026#34;, 26}, } sort.Sort(ByAge(people)) fmt.Println(\u0026#34;排序后:\u0026#34;, people) } 多字段可编程排序： // 定义基础类型 type Planet struct { name string mass float64 distance float64 } // 定义排序函数类型 type By func(p1, p2 *Planet) bool // 实现Sort方法 func (by By) Sort(planets []Planet) { ps := \u0026amp;planetSorter{ planets: planets, by: by, } sort.Sort(ps) } // 实现sort.Interface type planetSorter struct { planets []Planet by func(p1, p2 *Planet) bool } func (s *planetSorter) Len() int { return len(s.planets) } func (s *planetSorter) Swap(i, j int) { s.planets[i], s.planets[j] = s.planets[j], s.planets[i] } func (s *planetSorter) Less(i, j int) bool { return s.by(\u0026amp;s.planets[i], \u0026amp;s.planets[j]) } func main() { planets := []Planet{ {\u0026#34;Mercury\u0026#34;, 0.055, 0.4}, {\u0026#34;Venus\u0026#34;, 0.815, 0.7}, {\u0026#34;Earth\u0026#34;, 1.0, 1.0}, {\u0026#34;Mars\u0026#34;, 0.107, 1.5}, } // 定义不同的排序规则 name := func(p1, p2 *Planet) bool { return p1.name \u0026lt; p2.name } mass := func(p1, p2 *Planet) bool { return p1.mass \u0026lt; p2.mass } distance := func(p1, p2 *Planet) bool { return p1.distance \u0026lt; p2.distance } // 使用不同规则排序 By(name).Sort(planets) fmt.Println(\u0026#34;按名称排序:\u0026#34;, planets) By(mass).Sort(planets) fmt.Println(\u0026#34;按质量排序:\u0026#34;, planets) By(distance).Sort(planets) fmt.Println(\u0026#34;按距离排序:\u0026#34;, planets) } 使用二分查找： func main() { numbers := []int{1, 3, 6, 8, 10, 15, 21, 28} // 查找大于等于13的第一个数的位置 x := 13 i := sort.Search(len(numbers), func(i int) bool { return numbers[i] \u0026gt;= x }) if i \u0026lt; len(numbers) { fmt.Printf(\u0026#34;找到最小的大于等于%d的数：%d\\n\u0026#34;, x, numbers[i]) } } 性能特征 时间复杂度：\n一般排序：O(n log n) 稳定排序：O(n log n) 二分查找：O(log n) 空间复杂度：\nSort：O(log n) Stable：O(n) 使用建议 优先使用 sort.Slice 和 sort.SliceStable：\n代码更简洁 无需定义新类型 可以直接使用闭包访问外部变量 在以下情况下实现 sort.Interface：\n需要频繁复用的排序逻辑 需要在包级别提供排序功能 需要更好的代码组织和封装 使用 sort.Stable 当：\n需要保持相等元素的原始顺序 排序结果需要稳定性保证 高级排序技巧：\n使用 sort.Reverse 实现降序排序 实现多字段排序时考虑使用可编程排序模式 对于已排序的数据，使用 sort.Search 进行高效查找 container包 Go语言的container包提供了三个通用的容器数据结构实现：\ncontainer/heap: 堆实现 container/list: 双向链表实现 container/ring: 循环链表实现 container/heap包 heap包提供了堆（优先队列）的实现。堆是一个树形数据结构，其中每个父节点的值都小于或等于其子节点的值（最小堆）或大于或等于其子节点的值（最大堆）。\n接口和方法 // heap.Interface 接口定义了堆操作所需的方法 type Interface interface { sort.Interface // 继承 Len()、Less(i, j int)、Swap(i, j int) Push(x any) // 添加x到末尾 Pop() any // 移除并返回最后一个元素 } // 包级函数 func Init(h Interface) // 将数据初始化为一个堆 func Push(h Interface, x any) // 将元素x压入堆 func Pop(h Interface) any // 弹出并返回堆顶元素 func Remove(h Interface, i int) any // 移除索引i处的元素 func Fix(h Interface, i int) // 重新建立索引i处元素的堆排序 使用示例 基本整数最小堆： package main import ( \u0026#34;container/heap\u0026#34; \u0026#34;fmt\u0026#34; ) // IntHeap 是一个由整数组成的最小堆 type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x any) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } func main() { h := \u0026amp;IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) fmt.Printf(\u0026#34;最小值: %d\\n\u0026#34;, (*h)[0]) for h.Len() \u0026gt; 0 { fmt.Printf(\u0026#34;%d \u0026#34;, heap.Pop(h)) } } 优先队列实现： // Item 表示优先队列中的一个元素 type Item struct { value string // 元素的值 priority int // 元素的优先级 index int // 元素在堆中的索引 } // PriorityQueue 实现了 heap.Interface 接口 type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { return pq[i].priority \u0026lt; pq[j].priority } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j } func (pq *PriorityQueue) Push(x any) { n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueue) Pop() any { old := *pq n := len(old) item := old[n-1] old[n-1] = nil // 避免内存泄漏 item.index = -1 // 为了安全 *pq = old[0 : n-1] return item } // 更新修改优先队列中的项 func (pq *PriorityQueue) update(item *Item, value string, priority int) { item.value = value item.priority = priority heap.Fix(pq, item.index) } func main() { // 创建一个优先队列并添加一些项 items := map[string]int{ \u0026#34;任务1\u0026#34;: 3, \u0026#34;任务2\u0026#34;: 1, \u0026#34;任务3\u0026#34;: 4, } pq := make(PriorityQueue, len(items)) i := 0 for value, priority := range items { pq[i] = \u0026amp;Item{ value: value, priority: priority, index: i, } i++ } heap.Init(\u0026amp;pq) // 插入一个新元素 item := \u0026amp;Item{ value: \u0026#34;任务4\u0026#34;, priority: 2, } heap.Push(\u0026amp;pq, item) // 更新一个元素 pq.update(item, \u0026#34;任务4-更新\u0026#34;, 0) // 按优先级顺序取出所有元素 for pq.Len() \u0026gt; 0 { item := heap.Pop(\u0026amp;pq).(*Item) fmt.Printf(\u0026#34;%.2d:%s \u0026#34;, item.priority, item.value) } } 定时器实现示例： type Timer struct { expiry time.Time callback func() index int } type TimerHeap []*Timer func (h TimerHeap) Len() int { return len(h) } func (h TimerHeap) Less(i, j int) bool { return h[i].expiry.Before(h[j].expiry) } func (h TimerHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] h[i].index = i h[j].index = j } func (h *TimerHeap) Push(x any) { n := len(*h) timer := x.(*Timer) timer.index = n *h = append(*h, timer) } func (h *TimerHeap) Pop() any { old := *h n := len(old) timer := old[n-1] old[n-1] = nil timer.index = -1 *h = old[0 : n-1] return timer } func main() { th := \u0026amp;TimerHeap{} heap.Init(th) // 添加定时器 now := time.Now() heap.Push(th, \u0026amp;Timer{ expiry: now.Add(2 * time.Second), callback: func() { fmt.Println(\u0026#34;Timer 1 expired\u0026#34;) }, }) heap.Push(th, \u0026amp;Timer{ expiry: now.Add(1 * time.Second), callback: func() { fmt.Println(\u0026#34;Timer 2 expired\u0026#34;) }, }) // 模拟定时器触发 for th.Len() \u0026gt; 0 { timer := heap.Pop(th).(*Timer) fmt.Printf(\u0026#34;Timer will expire at: %v\\n\u0026#34;, timer.expiry) } } 性能特征 时间复杂度：\nPush：O(log n) Pop：O(log n) Remove：O(log n) Fix：O(log n) Init：O(n) Top（查看堆顶）：O(1) 空间复杂度：\n存储：O(n) 每个操作的额外空间：O(1) 使用建议 适用场景：\n优先队列实现 任务调度系统 事件定时器 数据流中位数计算 Dijkstra最短路径算法 合并多个有序序列 最佳实践：\n优先使用 heap 包提供的函数而不是直接操作底层切片 实现 heap.Interface 时注意维护元素的索引 使用指针接收器来避免不必要的复制 在 Pop 方法中将移除的元素置为 nil 以避免内存泄漏 注意事项：\n堆的第一个元素（索引0）始终是最小值（最小堆） 修改堆中元素后需要调用 Fix 来维护堆的性质 Push 和 Pop 方法操作的是切片的末尾元素 确保正确实现 Less 方法以决定最小堆或最大堆 替代方案：\n需要有序集合时考虑使用 sort 包 需要快速查找时考虑使用 map 需要并发安全的优先队列时考虑使用 channel 需要持久化的优先队列时考虑使用数据库 container/list包 list包实现了一个双向链表。双向链表中的每个节点都包含一个值和两个指针，分别指向前一个节点和后一个节点。\n结构和方法 List 结构体定义：\ntype List struct { root Element // 哨兵节点，root.next 指向第一个元素 len int // 当前链表长度 } type Element struct { next, prev *Element // 下一个和前一个元素的指针 list *List // 元素所属的链表 Value any // 元素值 } // 主要方法 func New() *List // 创建一个新的链表 func (l *List) Init() // 初始化或清空链表 func (l *List) Front() *Element // 返回第一个元素 func (l *List) Back() *Element // 返回最后一个元素 func (l *List) Len() int // 返回链表长度 func (l *List) PushFront(v any) // 在链表前端插入元素 func (l *List) PushBack(v any) // 在链表后端插入元素 func (l *List) InsertBefore(v any, mark *Element) // 在指定元素前插入 func (l *List) InsertAfter(v any, mark *Element) // 在指定元素后插入 func (l *List) PushFrontList(other *List) // 在链表前端插入另一个链表 func (l *List) PushBackList(other *List) // 在链表后端插入另一个链表 func (l *List) MoveToFront(e *Element) // 将元素移到链表前端 func (l *List) MoveToBack(e *Element) // 将元素移到链表后端 func (l *List) MoveBefore(e, mark *Element) // 将元素移到指定元素之前 func (l *List) MoveAfter(e, mark *Element) // 将元素移到指定元素之后 func (l *List) Remove(e *Element) // 移除指定元素 使用示例 基本操作示例： package main import ( \u0026#34;container/list\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 创建新链表 l := list.New() // 在后面添加元素 l.PushBack(\u0026#34;first\u0026#34;) l.PushBack(\u0026#34;second\u0026#34;) // 在前面添加元素 l.PushFront(\u0026#34;zero\u0026#34;) // 遍历并打印 for e := l.Front(); e != nil; e = e.Next() { fmt.Printf(\u0026#34;%v \u0026#34;, e.Value) } // 输出: zero first second } 元素操作示例： func listOperations() { l := list.New() // 添加元素并保存引用 e4 := l.PushBack(4) e1 := l.PushFront(1) // 在特定位置插入 l.InsertBefore(3, e4) // 在4前插入3 l.InsertAfter(2, e1) // 在1后插入2 // 移动元素 e := l.Front() l.MoveToBack(e) // 将第一个元素移到末尾 // 删除元素 l.Remove(e4) } 实现LRU缓存示例： type LRUCache struct { capacity int cache map[string]*list.Element list *list.List } func NewLRUCache(capacity int) *LRUCache { return \u0026amp;LRUCache{ capacity: capacity, cache: make(map[string]*list.Element), list: list.New(), } } func (c *LRUCache) Get(key string) (string, bool) { if elem, ok := c.cache[key]; ok { c.list.MoveToFront(elem) // 最近访问的移到前面 return elem.Value.(string), true } return \u0026#34;\u0026#34;, false } func (c *LRUCache) Put(key, value string) { if elem, ok := c.cache[key]; ok { c.list.MoveToFront(elem) elem.Value = value return } if c.list.Len() \u0026gt;= c.capacity { // 删除最久未使用的元素 back := c.list.Back() delete(c.cache, back.Value.(string)) c.list.Remove(back) } // 添加新元素 elem := c.list.PushFront(value) c.cache[key] = elem } 性能特征 时间复杂度：\n插入/删除：O(1) 查找：O(n) 访问头尾元素：O(1) 空间复杂度：\n每个节点需要额外的前后指针存储空间 总体空间复杂度：O(n) 适用场景 LRU（最近最少使用）缓存 任务队列 历史记录管理 撤销/重做功能实现 需要频繁插入删除的场景 需要双向遍历的场景 使用建议 当需要频繁的插入、删除操作时，优先使用 list 而不是切片 如果主要是随机访问操作，建议使用切片而不是链表 注意保存 Element 指针以便快速操作特定元素 使用 Remove 方法删除元素时要确保元素确实在链表中 container/ring包 ring包实现了环形链表的操作。环形链表是一种特殊的链表，其中最后一个元素指向第一个元素，形成一个环。\n结构和方法 // Ring 是环形链表的一个元素，也代表整个环 type Ring struct { next, prev *Ring Value any // 用于存储元素值 } // 主要方法 func New(n int) *Ring // 创建一个长度为n的环 func (r *Ring) Do(f func(any)) // 对环中的每个元素执行函数f func (r *Ring) Len() int // 返回环的长度 func (r *Ring) Link(s *Ring) *Ring // 将两个环连接在一起 func (r *Ring) Move(n int) *Ring // 移动n个位置（n可以是负数） func (r *Ring) Next() *Ring // 返回下一个元素 func (r *Ring) Prev() *Ring // 返回前一个元素 func (r *Ring) Unlink(n int) *Ring // 从当前元素开始移除n个元素 使用示例 创建和遍历环： package main import ( \u0026#34;container/ring\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 创建一个长度为5的环 r := ring.New(5) // 初始化环的值 for i := 0; i \u0026lt; r.Len(); i++ { r.Value = i r = r.Next() } // 使用Do方法遍历环 r.Do(func(p any) { fmt.Printf(\u0026#34;%d \u0026#34;, p) }) fmt.Println() // 输出: 0 1 2 3 4 } 环的连接和分割： func main() { // 创建两个环 r1 := ring.New(3) r2 := ring.New(2) // 初始化第一个环 for i := 0; i \u0026lt; r1.Len(); i++ { r1.Value = fmt.Sprintf(\u0026#34;r1-%d\u0026#34;, i) r1 = r1.Next() } // 初始化第二个环 for i := 0; i \u0026lt; r2.Len(); i++ { r2.Value = fmt.Sprintf(\u0026#34;r2-%d\u0026#34;, i) r2 = r2.Next() } // 连接两个环 r3 := r1.Link(r2) // 遍历新环 r3.Do(func(p any) { fmt.Printf(\u0026#34;%s \u0026#34;, p) }) fmt.Println() // 输出: r1-0 r1-1 r1-2 r2-0 r2-1 // 分割环 r4 := r3.Unlink(2) fmt.Print(\u0026#34;第一部分: \u0026#34;) r3.Do(func(p any) { fmt.Printf(\u0026#34;%s \u0026#34;, p) }) fmt.Println() fmt.Print(\u0026#34;第二部分: \u0026#34;) r4.Do(func(p any) { fmt.Printf(\u0026#34;%s \u0026#34;, p) }) fmt.Println() } 环的移动操作： func main() { // 创建环并初始化 r := ring.New(5) for i := 0; i \u0026lt; r.Len(); i++ { r.Value = i r = r.Next() } // 向前移动2个位置 r = r.Move(2) fmt.Printf(\u0026#34;当前值: %d\\n\u0026#34;, r.Value) // 向后移动1个位置 r = r.Move(-1) fmt.Printf(\u0026#34;当前值: %d\\n\u0026#34;, r.Value) // 使用Next()和Prev() fmt.Printf(\u0026#34;下一个值: %d\\n\u0026#34;, r.Next().Value) fmt.Printf(\u0026#34;前一个值: %d\\n\u0026#34;, r.Prev().Value) } 实现循环缓冲区： type CircularBuffer struct { *ring.Ring size int } func NewCircularBuffer(size int) *CircularBuffer { return \u0026amp;CircularBuffer{ Ring: ring.New(size), size: size, } } func (c *CircularBuffer) Add(value any) { c.Value = value c.Ring = c.Next() } func (c *CircularBuffer) GetAll() []any { values := make([]any, 0, c.size) c.Do(func(p any) { if p != nil { values = append(values, p) } }) return values } func main() { // 创建一个大小为3的循环缓冲区 buffer := NewCircularBuffer(3) // 添加4个元素（第4个会覆盖第1个） buffer.Add(\u0026#34;A\u0026#34;) buffer.Add(\u0026#34;B\u0026#34;) buffer.Add(\u0026#34;C\u0026#34;) buffer.Add(\u0026#34;D\u0026#34;) // 获取所有元素 values := buffer.GetAll() fmt.Println(values) // 输出: [D B C] 或类似序列 } 性能特征 时间复杂度：\n创建环：O(n) 遍历（Do）：O(n) 移动（Move）：O(n) 对于大的n；O(1) 对于小的n 连接（Link）：O(1) 分割（Unlink）：O(n) 空间复杂度：\n基本存储：O(n) 每个元素额外需要两个指针（next和prev） 适用场景 循环缓冲区 轮询调度算法 循环列表处理 固定大小的循环队列 使用建议 适用场景：\n循环缓冲区实现 轮询调度算法 循环列表处理 固定大小的循环队列 最佳实践：\n使用 Do 方法进行安全遍历 注意保持对环的起始位置的引用 在修改环结构时要小心处理指针 考虑使用辅助函数封装常见操作 注意事项：\nRing的零值是一个长度为1的空环 Link和Unlink操作会改变环的结构 Move的参数可以是负数，表示反向移动 Value字段是any类型，使用时需要类型断言 替代方案：\n需要动态大小时考虑使用切片 需要并发安全时考虑使用channel 需要快速随机访问时考虑使用数组 ","date":"2025-02-19T00:00:00Z","permalink":"/p/go%E6%A0%87%E5%87%86%E5%BA%93-container%E5%8C%85%E4%B8%8Esort%E5%8C%85/","title":"Go标准库 - container包与sort包"},{"content":"题目描述 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n解题思路 这道题最优解法是使用快速选择算法（Quick Select），它是快速排序的变体。主要思路如下：\n使用快速选择算法，每次选择一个基准值（pivot） 将数组分为大于基准值和小于基准值的两部分 根据基准值的位置，判断第k大的元素在哪一部分，只递归搜索那一部分 重复以上步骤直到找到第k大的元素 时间复杂度分析：\n平均时间复杂度：O(n) 最坏时间复杂度：O(n²) 空间复杂度：O(1) 图解示例 让我们通过一个具体的例子来说明快速选择算法的工作过程。以查找第2大元素为例：\n↺ graph TD subgraph 初始数组 A[3,2,1,5,6,4] end subgraph 第一次分区 B[\u0026#34;选择pivot=4\u0026#34;] C[\u0026#34;小于4: [3,2,1] | 4 | 大于4: [5,6]\u0026#34;] end subgraph 结果定位 D[\u0026#34;数组变为: [3,2,1,4,5,6]\u0026#34;] E[\u0026#34;pivot位置=3\u0026#34;] F[\u0026#34;目标=第2大(即索引4)\u0026#34;] G[\u0026#34;在右半部分继续查找\u0026#34;] end subgraph 第二次分区 H[\u0026#34;在[5,6]中选择pivot=6\u0026#34;] I[\u0026#34;小于6: [5] | 6\u0026#34;] J[\u0026#34;找到第2大元素: 5\u0026#34;] end A --\u0026gt; B B --\u0026gt; C C --\u0026gt; D D --\u0026gt; E E --\u0026gt; F F --\u0026gt; G G --\u0026gt; H H --\u0026gt; I I --\u0026gt; J style A fill:#f9f,stroke:#333,stroke-width:2px style J fill:#9f9,stroke:#333,stroke-width:2px 算法步骤说明 初始状态：数组为[3,2,1,5,6,4]，要找第2大的元素 第一次分区： 选择4作为基准值（pivot） 将数组分为小于4的部分[3,2,1]和大于4的部分[5,6] 4的位置在索引3，而我们需要找的是索引4（倒数第2个位置） 因此需要在右半部分[5,6]中继续查找 第二次分区： 在[5,6]中选择6作为基准值 分区后得到[5]和[6] 5正好在倒数第2个位置，即为所求 ↺ graph LR subgraph 数组状态变化 A[\u0026#34;[3,2,1,5,6,4]\u0026#34;] --\u0026gt;|\u0026#34;第一次分区\u0026#34;| B[\u0026#34;[3,2,1,4,5,6]\u0026#34;] B --\u0026gt;|\u0026#34;第二次分区\u0026#34;| C[\u0026#34;[3,2,1,4,5,6]\u0026#34;] end style A fill:#f9f,stroke:#333,stroke-width:2px style C fill:#9f9,stroke:#333,stroke-width:2px 为什么是O(n)时间复杂度？ ↺ graph TD subgraph 时间复杂度分析 A[\u0026#34;第一次遍历: n个元素\u0026#34;] B[\u0026#34;第二次遍历: n/2个元素\u0026#34;] C[\u0026#34;第三次遍历: n/4个元素\u0026#34;] D[\u0026#34;...\u0026#34;] A --\u0026gt; B B --\u0026gt; C C --\u0026gt; D E[\u0026#34;总时间 = n + n/2 + n/4 + ... \u0026lt; 2n\u0026#34;] D --\u0026gt; E end style E fill:#9f9,stroke:#333,stroke-width:2px 每次分区操作都会将问题规模减半，并且我们只需要处理其中的一半。这形成了等比数列：\nT(n) = n + n/2 + n/4 + n/8 + \u0026hellip; 这个级数的和小于2n 因此时间复杂度为O(n) 代码实现 func findKthLargest(nums []int, k int) int { // 将第k大转换为第n-k+1小，这样更容易理解 k = len(nums) - k return quickSelect(nums, 0, len(nums)-1, k) } func quickSelect(nums []int, left, right, k int) int { if left == right { return nums[left] } // 选择基准值的位置 pivotIndex := partition(nums, left, right) if pivotIndex == k { return nums[k] } else if pivotIndex \u0026lt; k { return quickSelect(nums, pivotIndex+1, right, k) } return quickSelect(nums, left, pivotIndex-1, k) } func partition(nums []int, left, right int) int { // 选择最右边的元素作为基准值 pivot := nums[right] i := left for j := left; j \u0026lt; right; j++ { if nums[j] \u0026lt;= pivot { nums[i], nums[j] = nums[j], nums[i] i++ } } nums[i], nums[right] = nums[right], nums[i] return i } 复杂度分析 时间复杂度：O(n)\n虽然最坏情况下是O(n²)，但平均时间复杂度是O(n) 这是因为每次partition后，我们只需要递归处理一半的数据 空间复杂度：O(1)\n原地排序，只需要常数级别的额外空间 示例 输入: nums = [3,2,1,5,6,4], k = 2 输出: 5 解释: 数组排序后为 [1,2,3,4,5,6]，第2大的元素是5 注意事项 这个解法会修改原数组，如果不想修改原数组，需要先复制一份 为了优化最坏情况，可以随机选择基准值 如果数组中有大量重复元素，可以使用三路快排的思想进行优化 ","date":"2025-02-18T00:00:00Z","permalink":"/p/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","title":"第k个最大元素"},{"content":"ChatGPT 客户端 OpenAI 的 ChatGPT 有两种方式使用，分别是网页版，也就是 chat.openai.com，以及 API，前者已经屏蔽了亚洲区域，并且大型 IDC 的梯子也都上不去，所以使用 API 的方式更为便捷。 这里介绍一下常见的客户端。\nIOS\nOpenCat AMA AssisChat Android\nMacOS\nOpenCat Windows\nWeb\nOpenCat 使用 下载 APP OpenCat 打开 APP，点击右下角 Settings 按钮，输入 API Key 3. 点击校验没问题即可使用 使用代理 如果没有OpenAI的账号或者IP被墙，可以使用FastGo，提供的中转功能\n打开左侧客户端 点击生成Key 复制自己的key\n在客户端中输入自己的Key\n客户端中自定义API域名，以OpenCat为例，输入api.fastgo.run\n","date":"2023-04-07T06:08:46+08:00","permalink":"/p/chatgpt-%E5%AE%A2%E6%88%B7%E7%AB%AF/","title":"ChatGPT 客户端"},{"content":"Vue 加载文件为文本格式 使用Vue开发的时候，我们可能需要读取文本文件，这个时候需要使用raw-loader\n安装 npm install raw-loader --save-dev 使用 这里以读取yaml文件为例：\nconst foo = require(\u0026#39;!raw-loader!pages/template/foo.yaml\u0026#39;) console.log(foo.default) ","date":"2022-11-06T22:37:04+08:00","permalink":"/p/vue-%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B8%BA%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/","title":"Vue 加载文件为文本格式"},{"content":"Kubernetes创建普通用户kubeconfig 提供kubernetes集群管理权限的方式包括使用kubeconfig以及serviceaccount，其中kubeconfig常用于在集群外部使用kubectl对集群进行调用。\n这里记录一下创建kubeconfig的方法。\n创建私钥 这里以创建用户myuser为例\nopenssl genrsa -out myuser.key 2048 openssl req -new -key myuser.key -out myuser.csr 其中Organization Name表示用户所属的组，Common Name为用户\n创建CertificateSigningRequest 需要使用kubectl创建证书签名请求\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: certificates.k8s.io/v1 kind: CertificateSigningRequest metadata: name: myuser spec: request: \u0026lt;CSR 文件内容的 base64 编码值。 要得到该值，可以执行命令 cat myuser.csr | base64 |\u0026gt; signerName: kubernetes.io/kube-apiserver-client usages: - client auth EOF 通过kubectl创建了myuser用户的证书签发请求\n批准证书 查看当前的证书签名请求\nkubectl get csr 批准请求\nkubectl certificate approve myuser 获取证书 将证书输出到myuser.crt中\nkubectl get csr myuser -o jsonpath=\u0026#39;{.status.certificate}\u0026#39;| base64 -d \u0026gt; myuser.crt 创建角色和角色绑定 如果是集群范围使用ClusterRole和ClusterRoleBinding，命名空间的使用Role和RoleBinding\n将用户myuser和Role绑定。\n添加到kubeconfig # 添加用户凭据 kubectl config set-credentials myuser --client-key=myuser.key --client-certificate=myuser.crt --embed-certs=true # 设置上下文 kubectl config set-context myuser --cluster=kubernetes --user=myuser # 使用上下文 kubectl config use-context myuser 这里上下文的集群kubernetes需要替换成自己的集群\n","date":"2022-11-02T19:21:47+08:00","permalink":"/p/kubernetes%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7kubeconfig/","title":"Kubernetes创建普通用户kubeconfig"},{"content":"使用git-crypt对Git仓库中的敏感文件进行加密 安装 依赖：\nDebian/Ubuntu package RHEL/Centos package Make make make A C++11 compiler (e.g. gcc 4.9+) g++ gcc-c++ OpenSSL development files libssl-dev openssl-devel 有以上依赖后可以安装git-crypt\n#!/bin/sh # install git-crypt mkdir ~/tmp cd ~/tmp git clone https://github.com/AGWA/git-crypt.git cd git-crypt make make install # clean rm -rf ~/tmp mac 安装：\nbrew install git-crypt 加密 git-crypt 初始化：\ngit-crypt init 配置需要加密的文件 在项目根目录中创建.gitattributes文件，这个文件可以设置哪些文件需要加密\n*.go filter=git-crypt diff=git-crypt *.yaml filter=git-crypt diff=git-crypt template.md filter=git-crypt diff=git-crypt output.md filter=git-crypt diff=git-crypt code/** filter=git-crypt diff=git-crypt 可以自定义需要加密的具体文件或者指定文件格式的文件或者是整个目录加密。\n导出密钥 git-crypt export-key ./git-crypt-key 在.gitignore中加入git-crypt-key来忽略key文件\n导出的密钥需要另外存放并且妥善保管，也可以使用base64编码key文件为文本格式：\ncat git-crypt-key | base64 # 需要导入密钥的时候可以解码base64 echo \u0026#34;\u0026lt;git-crypt-key 的base64编码\u0026gt;\u0026#34; | base64 -d \u0026gt; git-crypt-key 解密 解密需要有之前加密的key文件git-crypt-key\ngit-crypt unlock ./git-crypt-key 对于每个仓库之需要执行一次即可。\n","date":"2022-06-16T23:10:49+08:00","permalink":"/p/%E4%BD%BF%E7%94%A8git-crypt%E5%AF%B9git%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/","title":"使用git-crypt对Git仓库中的敏感文件进行加密"},{"content":"最近发现一篇文章Self-referential functions and the design of options介绍了一种很好的实现配置的方式，目前这种方式 在许多的开源库中被使用，比如GRPC：\nconn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials())) 例子 首先定义一个配置接口：\ntype option func(*Foo) 这里Foo就是我们需要实际操作的对象\n之后我们实现一个加载配置的方法：\nfunc (f *Foo) Option(opts ...option) { for _, opt := range opts { opt(f) } } 这里通过变长参数的方式将所有的option执行。\n下面实现一个具体的配置项：\nfunc Verbosity(v int) option { return func(f *Foo) { f.verbosity = v } } 通过闭包的方式构造一个option的函数，最后调用：\nfoo.Option(pkg.Verbosity(3)) 当然最后可以依据实际情况进行改造，原文中还对这种方法做了一点改进，这里就不说了，个人感觉grpc这种方式已经够大部分场景下使用了。\n","date":"2022-03-20T03:30:25+08:00","permalink":"/p/%E8%87%AA%E5%BC%95%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AE%BE%E8%AE%A1/","title":"自引用函数和配置设计"},{"content":"2022年3月15号，Go 1.18版本正式发布，泛型也在这个版本中被支持。\n下面简单的学习了下Go的泛型使用：\n基本使用 首先从最常用的max函数来看。 假设我现在需要两个int类型的最大值，原先的Go写法是：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(maxInt(32, 64)) } func maxInt(a, b int) int { if a \u0026gt; b { return a } return b } 这个时候我需要增加一个获取float64的最大值，那么我们就要新增一个函数叫maxFloat64：\nfunc maxFloat64(a, b float64) float64 { if a \u0026gt; b { return a } return b } 每当我们需要对一种类型进行比较的时候，我们都需要重新编写一个函数，尽管他们的逻辑其实都是一样的，将来甚至还需要int8、int16、int32等等的类型。\n当引入泛型之后，我们可以写成：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(max(1, 2)) fmt.Println(max[int32](1, 2)) fmt.Println(max(1.5, 2.3)) } func max[T int | int8 | int16 | int32 | int64 | float32 | float64](a, b T) T { if a \u0026gt; b { return a } return b } 当然，后面跟了一长串的int｜int8、、、这样实在有点费劲，如果我们之后需要增加一个min函数呢，岂不是又要把上面的这些抄一遍吗，所以这里还可以用interface提前定义下：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(max(1, 2)) fmt.Println(max[int32](1, 2)) fmt.Println(max(1.5, 2.3)) fmt.Println(min(1, 2)) fmt.Println(min[int32](1, 2)) fmt.Println(min(1.5, 2.3)) } type Number interface { int | int8 | int16 | int32 | int64 | float32 | float64 } func max[T Number](a, b T) T { if a \u0026gt; b { return a } return b } func min[T Number](a, b T) T { if a \u0026lt; b { return a } return b } 在结构体中使用泛型 除了函数声明中可以使用泛型，结构体中一样可以使用：\npackage main import ( \u0026#34;fmt\u0026#34; ) type Data[T comparable] struct { Message T } func (d Data[T]) Print() { fmt.Println(d.Message) } func main() { d := Data[int]{ Message: 66, } d.Print() } 这里有个类型：comparable\n可以看看go的源码里面写的：\n// comparable is an interface that is implemented by all comparable types // (booleans, numbers, strings, pointers, channels, arrays of comparable types, // structs whose fields are all comparable types). // The comparable interface may only be used as a type parameter constraint, // not as the type of a variable. type comparable interface{ comparable } 大概意思就是允许booleans, numbers, strings, pointers, channels, comparable类型组成的arrays以及所有字段都是由comparable类型组成的struct。\n这里也有一个any类型：\n// any is an alias for interface{} and is equivalent to interface{} in all ways. type any = interface{} 其实就是interface{}的别称。\n与interface{}性能对比 在没有泛型的时候，我们想要通常使用interface{}和断言来模拟泛型操作，比如我们构建一个简单的KV内存缓存：\ntype Message struct { message string } func NewStore() *Store { return \u0026amp;Store{ data: make(map[string]interface{}), } } type Store struct { data map[string]interface{} } func (s *Store) Get(k string) (interface{}, bool) { d, ok := s.data[k] return d, ok } func (s *Store) Set(k string, v interface{}) { s.data[k] = v } func (s *Store) Del(k string) { delete(s.data, k) } 这里我们定义的需要存储的类型为Message， 我们需要在内部使用一个map[string]interface{}来存放数据\n对应的插入、查找以及删除操作为：\ns.Set(\u0026#34;test\u0026#34;, \u0026amp;Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d.(Message) s.Del(\u0026#34;test\u0026#34;) 因为没有泛型，所以每次通过Get获取到的数据都需要进行一次断言，转换为我们期望的类型。\n当有了泛型之后，一切都变得简单了，我们不在需要断言，代码编程：\ntype TStore[K comparable, V any] struct { data map[K]V } func NewTStore[K comparable, V any]() *TStore[K, V] { return \u0026amp;TStore[K, V]{ data: make(map[K]V), } } func (s *TStore[K, V]) Get(k K) (V, bool) { d, ok := s.data[k] return d, ok } func (s *TStore[K, V]) Set(k K, v V) { s.data[k] = v } func (s *TStore[K, V]) Del(k K) { delete(s.data, k) } 这里用于存储数据的map变为通过泛型来实现，所以对应的操作简化为：\ns.Set(\u0026#34;test\u0026#34;, Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d s.Del(\u0026#34;test\u0026#34;) 与使用interface{}方法实现的相比，泛型的版本可以直接使用Get到的数据，而不用执行断言。\n下面我们可以跑下benchmark来看看两者的差别：\ngoos: linux goarch: amd64 pkg: generics cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics BenchmarkGenerice-8 32675426 35.01 ns/op 0 B/op 0 allocs/op BenchmarkInterface-8 17569459 67.05 ns/op 16 B/op 1 allocs/op PASS coverage: 0.0% of statements ok generics 2.433s interface {}实现的版本比泛型实现的版本的性能差一倍！\n下面贴上测试的完整代码：\npackage main import ( \u0026#34;testing\u0026#34; ) type TStore[K comparable, V any] struct { data map[K]V } func NewTStore[K comparable, V any]() *TStore[K, V] { return \u0026amp;TStore[K, V]{ data: make(map[K]V), } } func (s *TStore[K, V]) Get(k K) (V, bool) { d, ok := s.data[k] return d, ok } func (s *TStore[K, V]) Set(k K, v V) { s.data[k] = v } func (s *TStore[K, V]) Del(k K) { delete(s.data, k) } type Message struct { message string } func NewStore() *Store { return \u0026amp;Store{ data: make(map[string]interface{}), } } type Store struct { data map[string]interface{} } func (s *Store) Get(k string) (interface{}, bool) { d, ok := s.data[k] return d, ok } func (s *Store) Set(k string, v interface{}) { s.data[k] = v } func (s *Store) Del(k string) { delete(s.data, k) } func testT(s *TStore[string, Message]) { s.Set(\u0026#34;test\u0026#34;, Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d s.Del(\u0026#34;test\u0026#34;) } func BenchmarkGenerice(b *testing.B) { t := NewTStore[string, Message]() for n := 0; n \u0026lt; b.N; n++ { testT(t) // run fib(30) b.N times } } func test(s *Store) { s.Set(\u0026#34;test\u0026#34;, Message{message: \u0026#34;message\u0026#34;}) d, _ := s.Get(\u0026#34;test\u0026#34;) _ = d.(Message) s.Del(\u0026#34;test\u0026#34;) } func BenchmarkInterface(b *testing.B) { t := NewStore() for n := 0; n \u0026lt; b.N; n++ { test(t) // run fib(30) b.N times } } 强烈推荐大家升级到新版Go，体验下泛型。\n","date":"2022-03-17T11:42:12+08:00","permalink":"/p/go-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/","title":"Go 泛型使用与性能对比"},{"content":"当加载配置的时候，我们通常会将配置设置一个默认值，但是通常默认值不是Go中的空值，比如 服务的端口号：\ntype ServerConfig struct{ Port uint } func main(){ conf:=loadConfig() if conf.ServerConfig.Port==0{ conf.ServerConfig.Port = 8080 } } 每次有一个值我们都需要增加一个if语句进行判断，当一个配置有很多的时候，初始化写起来可能就非常的繁琐。\n幸运的是Go中提供了tag，我们可以借用tag，结合反射来实现默认值。\n原理比较简单大概流程就是：\n通过反射解析当前的结构体 查看当前字段的值时候为空值 如果为空，读取tag中的default，并初始化 不为空直接略过 具体代码可以参考：https://github.com/zzjcool/goutils/blob/main/defaults/defauls.go\n这里给出使用方法：\nDefaults Enforce default values on struct fields.\ntype User struct { Name string `default:\u0026#34;Goku\u0026#34;` Power float64 `default:\u0026#34;9000.01\u0026#34;` } var u User err := defaults.Apply(\u0026amp;u) if err != nil { log.Fatal(\u0026#34;Uh oh: %v\u0026#34;, err) } fmt.Print(u.Name) // Goku fmt.Print(u.Power) // 9000.01 Defaults are only applied to fields at their zero value.\ntype Config struct { Host *string `default:\u0026#34;0.0.0.0\u0026#34;` Port *int `default:\u0026#34;8000\u0026#34;` } var cfg Config json.Unmarshal([]byte(`{Host: \u0026#34;charm.sh\u0026#34;}`), \u0026amp;cfg) if err := defaults.Apply(\u0026amp;cfg); err != nil { log.Fatal(\u0026#34;Rats: %v\u0026#34;, err) } fmt.Print(cfg.Host) // charm.sh fmt.Print(cfg.Port) // 8000 Works well with JSON, Yaml, and so on.\ntype Config struct { Host string `json:\u0026#34;host\u0026#34; default:\u0026#34;0.0.0.0\u0026#34;` Port int `json:\u0026#34;port\u0026#34; default:\u0026#34;8000\u0026#34;` Debug bool `json:\u0026#34;debug\u0026#34; default:\u0026#34;true\u0026#34;` } Supported Types The following types are supported:\nstring bool int int8 int16 int32 (and rune, with some caveats) int64 uint uint8 uint16 uint32 uint64 float32 float64 []byte/[]uint8 …as well as pointers to those types.\nEmbedded Structs Embedded structs are supported. The following will parse as expected:\ntype GroceryList struct { Fruit struct { Bananas int `default:\u0026#34;8\u0026#34;` Pears int `default:\u0026#34;12\u0026#34;` } Vegetables *struct { Artichokes int `default:\u0026#34;4\u0026#34;` SweetPotatoes int `default:\u0026#34;16\u0026#34;` } } Embedded structs do not need a default tag in order to be parsed. Embedded structs that are nil will be initialized with their zero value so they can be parsed accoringly.\nRunes and Int32s In Go rune is just an alias for int32. This presents some ambiguity when parsing default values. For example, should \u0026quot;1\u0026quot; be parsed as a literal 1 or as a unicode '1' (which has the int32 value of 49)?\nBecause of this ambiguity we recommend avoiding setting defaults on runes. That said, this package defaults to parsing int32 as integers. Failing that, it tries to parse them as a rune.\n// This works as expected... type Cool struct { Fave32BitInteger int32 `default:\u0026#34;12\u0026#34;` FaveChar rune `default:\u0026#34;a\u0026#34;` } // ...but these will not. type UhOh struct { FaveChar rune `default:\u0026#34;3\u0026#34;` // this is a unicode ETX or ctrl+c FaveChar rune `default:\u0026#34;97\u0026#34;` // this is a unicode `a` } 这个package本来是： github.com/charmbracelet/defaults 但是原地址无法访问\n","date":"2022-03-15T23:41:23+08:00","permalink":"/p/go-struct-%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"Go Struct 默认值的实现"},{"content":"Go的groutine使用起来十分的方便，可以帮助开发者快速的实现支持并行的程序，但是并行的程序往往需要根据用户的不同需求进行调度，比较常用的有sync.WaitGroup，通常是用于等待多个groutine执行完毕后继续后续的任务。\n但是有时候我们需要多个groutine并行执行后同时等待一个条件满足后再继续执行后续任务，例如之前写的Reduce库提给阻塞的Add方法，当所有的数据flush后所有的Add都停止阻塞，这种行为类似于学校考试，在开考前所有同学提前到考场等待考试开始，考试的开始时间都是统一的，当考试时间到了，广播打铃，所有同学收到信号，开始考试。当然这个时候有同学迟到了，那么因为考试已经开始，他就可以直接进入考场开始考试。\n需求说明 需要一个Wait接口，当调用的时候，如果条件未满足，将阻塞，同时调用Done接口的表示条件已经满足，解除所有Wait的阻塞，Wait可以被多个groutine调用，多个Wait接口对应一个Done。\n如果发生错误，那么错误将通知给所有的Wait的groutine，\n接口设计 为了实现上述的需求，我们设计对应的接口：\ntype Interface interface { // Wait 可以阻塞当前Groutine，直到Done被调用，可以获取到Done传入的error Wait() error // Done 解除所有Wait的阻塞，如果发生错误，将error传入 Done(err error) } 实现细节 需要实现以上的需求，可以想到的方式有两种，一种是使用sync.WaitGroup，还有一种是使用sync.Cond。同时，根据这个组件的特性，我们把这个库取名为castwait\nsync.WaitGroup 实现方式 使用sync.WaitGroup实现起来比较简单，调用Add后，使用Wait后可以产生阻塞。\n设计，对应的结构体，为：\ntype castWait struct { wg sync.WaitGroup err error // 保存调用的错误 } 对应的接口实现为：\n// Wait 阻塞等待完成 func (c *castWait) Wait() error { c.wg.Wait() return c.err } // Done 完成 func (c *castWait) Done(err error) { c.err = err c.wg.Done() } sync.Cond 实现方式 sync.Cond包使用的比较少，具体的Cond包的使用可以参考：https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/，下次有时间再补充下sync.Cond的使用。\n结构的设计与接口的实现：\ntype condImpl struct { done bool C *sync.Cond err error } // Wait 阻塞等待完成 func (c *condImpl) Wait() error { c.C.L.Lock() defer c.C.L.Unlock() for !c.done { c.C.Wait() } return c.err } // Done 完成 func (c *condImpl) Done(err error) { c.err = err c.C.L.Lock() c.done = true c.C.L.Unlock() c.C.Broadcast() } 使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/castWait\u0026#34; // ) n := 100000 c := New() wg := sync.WaitGroup{} wg.Add(n) for i := 0; i \u0026lt; n; i += 1 { go func() { err := c.Wait() if err!=nil{ // do ... } wg.Done() }() } c.Done(exErr) wg.Wait() 仓库地址 https://github.com/zzjcool/goutils/tree/main/castwait\n","date":"2022-02-27T16:19:01+08:00","permalink":"/p/go%E5%8D%8F%E7%A8%8B%E5%AF%B9%E9%BD%90%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8Ccastwait%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"Go协程对齐，等待条件执行，Castwait库实现"},{"content":"在业务中我们可能经常会遇到某个接口需要高频的调用，例如数据库更新、插入操作，调用某api，在这里每一次的调用都会有额外的成本，所以无论是数据库还是一些api调用接口，都提供了批量操作的方式，通过批量操作来降低开销，提升效率。\n有的旧代码，或者业务本身不支持批量操作，所以我们需要对相关的数据进行聚合，转换为批量操作，个人认为这种操作有点类似于MapReduce操作中的Reduce，所以暂且称之为Reduce吧。\n需求 提供一个缓存，每次将单次的操作加入到这个缓存中，之后一次性从缓存中取出所有的数据，进行批量操作。\n当然何时将缓存全部取出来并进行操作也是个问题，所以我们希望可以传入两个值：\nmaxSize:表示缓存的最大大小 refreshMillisecond:表示缓存刷新的最短周期 也就是可以有两个条件可以触发批量操作，一个是固定时间，一个是达到缓存上限。\n为了模拟原来单次操作产生的阻塞，所以也应当支持阻塞，当该批所有的数据被批量处理完成后，代码可以执行下一步逻辑。\n同时应当可以捕获返回的错误，便于后续的处理。\n接口设计 type ReduceWait interface { Wait() error } type Interface interface { Add(data interface{}) ReduceWait Destroy() } 对于Reduce核心操作就是Add，其作用就是将数据插入到cache中，之后返回个ReduceWait接口。\nReduceWait接口只有一个方法Wait() error，当插入数据后，可以调用这个方法产生阻塞，等待到内部的数据被消费后将返回error类型。\n实现细节 具体实现部分主要是交由ReduceImple结构体来实现。除了实现Interface的接口的方法外，还有：\ndaemon：负责定时处理cache中积压的数据 refresh 刷新cache中所有的数据，将数据进行批量消费 在refresh的时候应当对Add操作上锁，保证同一时间只有一个refresh，或者Add在执行。\n同时比较麻烦的地方是调用Add的时候可能会因为Cache满了调用refresh，调用refresh的时候要保证没有其他的Add改变cache，所以Add需要一把锁 而refresh需要一把读写锁，其中refresh的读锁给Add。\nAdd返回的Wait我们使用casewait实现，每次refresh将原来的阻塞接触，开启新的casewait即可。\n在初始化的时候需要传入一个HandleFunc，这个函数的签名为type HandleFunc func(datas []interface{}) error 会在每一次的refresh操作中被调用，这里返回的error会被上抛到wait返回。\n使用方式 // import ( // \u0026#34;github.com/zzjcool/goutils/reduce\u0026#34; // ) // refresh调用的函数 doFunc := func(datas []interface{}) error { fmt.Println(len(datas)) return nil } // 创建一个reduce，300ms刷新一次，同时最大容量是100 rdc := reduce.New(doFunc, 300, 100) // 加入一个数据，同时同步等待完成，如果不调用就是异步操作 err := rdc.Add(\u0026#34;test\u0026#34;).Wait() if err != nil { fmt.Println(err) } 仓库地址 https://github.com/zzjcool/goutils/tree/main/reduce\n","date":"2022-02-20T18:04:30+08:00","permalink":"/p/%E4%B8%9A%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96reduce%E5%BA%93%E5%AE%9E%E7%8E%B0/","title":"业务性能优化，Reduce库实现"},{"content":"材料准备 主料 辣椒 猪肉 辅料 小米椒 玉米淀粉 油 糖 盐 生抽 老抽 鸡精 大蒜 准备工作 将猪肉切成丝，加入少量老抽和生抽，玉米淀粉腌制，使用淀粉腌制过的猪肉会更加的嫩，腌制十分钟左右就可以。 辣椒切开，掏出辣椒籽，放一旁备用，根据自己喜好可以加入适量来额小米椒。 大蒜切粒。 制作流程 热锅，加入食用油，等待油热。 将腌制的猪肉倒入锅中，大火翻炒，炒至变色后关火。 将肉倒出，放一旁备用。 剩下的油继续开火，放入大蒜。 等待有香味后加入辣椒翻炒。 炒一会后倒入之前的肉，加少量的糖。 加入适量的鸡精、盐、生抽以及少量老抽提色。 翻炒后出锅 成品总结 辣椒炒肉 第一次炒，肉放的太多了（主要还是盒马上买的一份辣椒份量实在是太少了），然后上海这里的辣椒都不是很辣，即使加入了小米椒，辣度还是有限。\n总体来说味道还是很不错的，从小最喜欢的一道菜。\n","date":"2022-02-15T12:06:06+08:00","image":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/ljcr_hu5ecfe790bedc4bd537f2edf54cfd5a05_316058_120x120_fill_q75_box_smart1.jpg","permalink":"/p/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/","title":"辣椒炒肉"},{"content":"Docker启动Nginx 可以使用docker-compose快速的启动Nginx docker-compose.yaml文件：\nversion: \u0026#39;3\u0026#39; services: nginx: image: nginx container_name: nginx network_mode: \u0026#34;host\u0026#34; volumes: - ./nginx:/etc/nginx/conf.d restart: unless-stopped 可以在当前目录下的nginx目录添加任意配置\nNginx 反向代理Websocket server { listen 48265; server_name \u0026#34;\u0026#34;; location / { proxy_pass http://domain:48265; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } 最后一行配置可以转发ws\n有时候我们的nginx反向代理会出错，但是我们检查发现上游服务器是正常的，那这可能 是因为反向代理后端发生dns解析的变动（如k8s服务重启或者ddns），所以 需要配置nginx的dns解析（resolver 8.8.8.8），同时反向代理的后端地址需要写为变量：\nserver { listen 48265; server_name \u0026#34;\u0026#34;; resolver 119.29.29.29 8.8.8.8 valid=30s; set $proxy_pass_url http://domain:48265; location / { proxy_pass $proxy_pass_url; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } } Nginx 直接显示系统目录 server { listen 8880; listen [::]:8880; server_name domain.com; location / { root /data; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8,gbk; } } 其中root /data表示实际的目录位置\n","date":"2022-01-07T10:33:38+08:00","permalink":"/p/nginx-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","title":"Nginx 相关配置"},{"content":"net/url 添加query 原本有url:http://domain.com, 现在想要添加query参数变成:http://domain.com?key=value\n可以自己写一个方法去添加query参数。\nfunc TestURL(t *testing.T) { api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) if err != nil { t.Fatal(err) } URLAddQuery(api, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) fmt.Println(api.String()) } // URLAddQuery 提供一个URL，然后添加query参数 func URLAddQuery(addr *url.URL, key, value string) { query := addr.Query() query.Add(key, value) addr.RawQuery = query.Encode() } url拼接path api, err := url.Parse(\u0026#34;http://domain.com\u0026#34;) api.Path = \u0026#34;/api/test\u0026#34; ","date":"2022-01-04T19:43:41+08:00","permalink":"/p/golang-%E5%86%85%E7%BD%AE%E5%8C%85%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","title":"Golang 内置包常用方法"}]