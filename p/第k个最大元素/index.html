<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="题目描述 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必"><title>第k个最大元素</title>
<link rel=canonical href=/p/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/><link rel=stylesheet href=/scss/style.min.775dbd4fd34fda61c5273b4bc3415f7c9666414fb6c40aab164a7ded4397da98.css><meta property="og:title" content="第k个最大元素"><meta property="og:description" content="题目描述 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必"><meta property="og:url" content="/p/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"><meta property="og:site_name" content="zzj的笔记"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="算法"><meta property="article:tag" content="数组"><meta property="article:tag" content="快速选择"><meta property="article:published_time" content="2025-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-18T00:00:00+00:00"><meta name=twitter:title content="第k个最大元素"><meta name=twitter:description content="题目描述 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必"></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/>算法题解</a></header><h2 class=article-title><a href=/p/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/>第k个最大元素</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 18, 2025</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><h2 id=题目描述>题目描述</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><h2 id=解题思路>解题思路</h2><p>这道题最优解法是使用快速选择算法（Quick Select），它是快速排序的变体。主要思路如下：</p><ol><li>使用快速选择算法，每次选择一个基准值（pivot）</li><li>将数组分为大于基准值和小于基准值的两部分</li><li>根据基准值的位置，判断第k大的元素在哪一部分，只递归搜索那一部分</li><li>重复以上步骤直到找到第k大的元素</li></ol><p>时间复杂度分析：</p><ul><li>平均时间复杂度：O(n)</li><li>最坏时间复杂度：O(n²)</li><li>空间复杂度：O(1)</li></ul><h2 id=图解示例>图解示例</h2><p>让我们通过一个具体的例子来说明快速选择算法的工作过程。以查找第2大元素为例：</p><div class=mermaid-wrapper><div class=mermaid-reset-wrapper><button class=mermaid-reset><span>↺</span></button></div><div class=mermaid-container><pre class=mermaid>graph TD
    subgraph 初始数组
    A[3,2,1,5,6,4]
    end
    
    subgraph 第一次分区
    B[&#34;选择pivot=4&#34;]
    C[&#34;小于4: [3,2,1]  |  4  |  大于4: [5,6]&#34;]
    end
    
    subgraph 结果定位
    D[&#34;数组变为: [3,2,1,4,5,6]&#34;]
    E[&#34;pivot位置=3&#34;]
    F[&#34;目标=第2大(即索引4)&#34;]
    G[&#34;在右半部分继续查找&#34;]
    end
    
    subgraph 第二次分区
    H[&#34;在[5,6]中选择pivot=6&#34;]
    I[&#34;小于6: [5]  |  6&#34;]
    J[&#34;找到第2大元素: 5&#34;]
    end
    
    A --&gt; B
    B --&gt; C
    C --&gt; D
    D --&gt; E
    E --&gt; F
    F --&gt; G
    G --&gt; H
    H --&gt; I
    I --&gt; J

style A fill:#f9f,stroke:#333,stroke-width:2px
style J fill:#9f9,stroke:#333,stroke-width:2px
    </pre></div></div><style>.mermaid-wrapper{position:relative;overflow:hidden;margin:1rem 0;cursor:grab;background-color:var(--pre-background-color);user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;height:450px}.mermaid-wrapper:active{cursor:grabbing}.mermaid-container{position:relative;transform-origin:0 0;transition:transform .1s ease;will-change:transform}.mermaid-reset{position:absolute;top:8px;right:8px;padding:8px;background:rgba(0,0,0,.6);color:#fff;border:none;border-radius:50%;cursor:pointer;opacity:0;transition:opacity .2s ease,background .2s ease;font-size:20px;width:36px;height:36px;display:flex;align-items:center;justify-content:center;z-index:100;pointer-events:auto}.mermaid-reset-wrapper{position:absolute;top:0;right:0;padding:16px;z-index:100;pointer-events:none}.mermaid-wrapper:hover .mermaid-reset{opacity:1}.mermaid-reset:hover{background:rgba(0,0,0,.8)}</style><script src=/js/lib/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"dark"}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{mermaid.initialize({startOnLoad:!0,theme:e.matches?"dark":"default"})})</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll(".mermaid-wrapper");e.forEach(e=>{const o=e.querySelector(".mermaid-container"),i=e.querySelector(".mermaid-reset");let s=!1,a,r,t=[1,0,0,1,0,0];function n(){o.style.transform=`matrix(${t.join(",")})`}e.addEventListener("wheel",s=>{s.preventDefault();const a=e.getBoundingClientRect(),c=s.clientX-a.left,l=s.clientY-a.top,r=t[0],f=o.getBoundingClientRect(),d=(c-t[4])/t[0],u=(l-t[5])/t[0],h=s.deltaY,m=h>0?.95:1.05,i=r*m;if(i>=.1&&i<=10){const e=i-r;t[0]=t[3]=i,t[4]+=-(d*e),t[5]+=-(u*e),n()}}),e.addEventListener("mousedown",n=>{if(n.target===i)return;s=!0,a=n.clientX-t[4],r=n.clientY-t[5],e.style.cursor="grabbing"}),document.addEventListener("mousemove",e=>{if(!s)return;t[4]=e.clientX-a,t[5]=e.clientY-r,n()}),document.addEventListener("mouseup",()=>{s=!1,e.style.cursor="grab"}),i.addEventListener("click",()=>{t=[1,0,0,1,0,0],n()}),e.addEventListener("dblclick",()=>{t=[1,0,0,1,0,0],n()})})})</script><h3 id=算法步骤说明>算法步骤说明</h3><ol><li><strong>初始状态</strong>：数组为[3,2,1,5,6,4]，要找第2大的元素</li><li><strong>第一次分区</strong>：<ul><li>选择4作为基准值（pivot）</li><li>将数组分为小于4的部分[3,2,1]和大于4的部分[5,6]</li><li>4的位置在索引3，而我们需要找的是索引4（倒数第2个位置）</li><li>因此需要在右半部分[5,6]中继续查找</li></ul></li><li><strong>第二次分区</strong>：<ul><li>在[5,6]中选择6作为基准值</li><li>分区后得到[5]和[6]</li><li>5正好在倒数第2个位置，即为所求</li></ul></li></ol><div class=mermaid-wrapper><div class=mermaid-reset-wrapper><button class=mermaid-reset><span>↺</span></button></div><div class=mermaid-container><pre class=mermaid>graph LR
    subgraph 数组状态变化
    A[&#34;[3,2,1,5,6,4]&#34;] --&gt;|&#34;第一次分区&#34;| B[&#34;[3,2,1,4,5,6]&#34;]
    B --&gt;|&#34;第二次分区&#34;| C[&#34;[3,2,1,4,5,6]&#34;]
    end
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style C fill:#9f9,stroke:#333,stroke-width:2px
    </pre></div></div><style>.mermaid-wrapper{position:relative;overflow:hidden;margin:1rem 0;cursor:grab;background-color:var(--pre-background-color);user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;height:450px}.mermaid-wrapper:active{cursor:grabbing}.mermaid-container{position:relative;transform-origin:0 0;transition:transform .1s ease;will-change:transform}.mermaid-reset{position:absolute;top:8px;right:8px;padding:8px;background:rgba(0,0,0,.6);color:#fff;border:none;border-radius:50%;cursor:pointer;opacity:0;transition:opacity .2s ease,background .2s ease;font-size:20px;width:36px;height:36px;display:flex;align-items:center;justify-content:center;z-index:100;pointer-events:auto}.mermaid-reset-wrapper{position:absolute;top:0;right:0;padding:16px;z-index:100;pointer-events:none}.mermaid-wrapper:hover .mermaid-reset{opacity:1}.mermaid-reset:hover{background:rgba(0,0,0,.8)}</style><script src=/js/lib/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"dark"}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{mermaid.initialize({startOnLoad:!0,theme:e.matches?"dark":"default"})})</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll(".mermaid-wrapper");e.forEach(e=>{const o=e.querySelector(".mermaid-container"),i=e.querySelector(".mermaid-reset");let s=!1,a,r,t=[1,0,0,1,0,0];function n(){o.style.transform=`matrix(${t.join(",")})`}e.addEventListener("wheel",s=>{s.preventDefault();const a=e.getBoundingClientRect(),c=s.clientX-a.left,l=s.clientY-a.top,r=t[0],f=o.getBoundingClientRect(),d=(c-t[4])/t[0],u=(l-t[5])/t[0],h=s.deltaY,m=h>0?.95:1.05,i=r*m;if(i>=.1&&i<=10){const e=i-r;t[0]=t[3]=i,t[4]+=-(d*e),t[5]+=-(u*e),n()}}),e.addEventListener("mousedown",n=>{if(n.target===i)return;s=!0,a=n.clientX-t[4],r=n.clientY-t[5],e.style.cursor="grabbing"}),document.addEventListener("mousemove",e=>{if(!s)return;t[4]=e.clientX-a,t[5]=e.clientY-r,n()}),document.addEventListener("mouseup",()=>{s=!1,e.style.cursor="grab"}),i.addEventListener("click",()=>{t=[1,0,0,1,0,0],n()}),e.addEventListener("dblclick",()=>{t=[1,0,0,1,0,0],n()})})})</script><h3 id=为什么是on时间复杂度>为什么是O(n)时间复杂度？</h3><div class=mermaid-wrapper><div class=mermaid-reset-wrapper><button class=mermaid-reset><span>↺</span></button></div><div class=mermaid-container><pre class=mermaid>graph TD
    subgraph 时间复杂度分析
    A[&#34;第一次遍历: n个元素&#34;]
    B[&#34;第二次遍历: n/2个元素&#34;]
    C[&#34;第三次遍历: n/4个元素&#34;]
    D[&#34;...&#34;]
    
    A --&gt; B
    B --&gt; C
    C --&gt; D
    
    E[&#34;总时间 = n + n/2 + n/4 + ... &lt; 2n&#34;]
    
    D --&gt; E
    end
    
    style E fill:#9f9,stroke:#333,stroke-width:2px
    </pre></div></div><style>.mermaid-wrapper{position:relative;overflow:hidden;margin:1rem 0;cursor:grab;background-color:var(--pre-background-color);user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;height:450px}.mermaid-wrapper:active{cursor:grabbing}.mermaid-container{position:relative;transform-origin:0 0;transition:transform .1s ease;will-change:transform}.mermaid-reset{position:absolute;top:8px;right:8px;padding:8px;background:rgba(0,0,0,.6);color:#fff;border:none;border-radius:50%;cursor:pointer;opacity:0;transition:opacity .2s ease,background .2s ease;font-size:20px;width:36px;height:36px;display:flex;align-items:center;justify-content:center;z-index:100;pointer-events:auto}.mermaid-reset-wrapper{position:absolute;top:0;right:0;padding:16px;z-index:100;pointer-events:none}.mermaid-wrapper:hover .mermaid-reset{opacity:1}.mermaid-reset:hover{background:rgba(0,0,0,.8)}</style><script src=/js/lib/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"dark"}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{mermaid.initialize({startOnLoad:!0,theme:e.matches?"dark":"default"})})</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll(".mermaid-wrapper");e.forEach(e=>{const o=e.querySelector(".mermaid-container"),i=e.querySelector(".mermaid-reset");let s=!1,a,r,t=[1,0,0,1,0,0];function n(){o.style.transform=`matrix(${t.join(",")})`}e.addEventListener("wheel",s=>{s.preventDefault();const a=e.getBoundingClientRect(),c=s.clientX-a.left,l=s.clientY-a.top,r=t[0],f=o.getBoundingClientRect(),d=(c-t[4])/t[0],u=(l-t[5])/t[0],h=s.deltaY,m=h>0?.95:1.05,i=r*m;if(i>=.1&&i<=10){const e=i-r;t[0]=t[3]=i,t[4]+=-(d*e),t[5]+=-(u*e),n()}}),e.addEventListener("mousedown",n=>{if(n.target===i)return;s=!0,a=n.clientX-t[4],r=n.clientY-t[5],e.style.cursor="grabbing"}),document.addEventListener("mousemove",e=>{if(!s)return;t[4]=e.clientX-a,t[5]=e.clientY-r,n()}),document.addEventListener("mouseup",()=>{s=!1,e.style.cursor="grab"}),i.addEventListener("click",()=>{t=[1,0,0,1,0,0],n()}),e.addEventListener("dblclick",()=>{t=[1,0,0,1,0,0],n()})})})</script><p>每次分区操作都会将问题规模减半，并且我们只需要处理其中的一半。这形成了等比数列：</p><ul><li>T(n) = n + n/2 + n/4 + n/8 + &mldr;</li><li>这个级数的和小于2n</li><li>因此时间复杂度为O(n)</li></ul><h2 id=代码实现>代码实现</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>findKthLargest</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将第k大转换为第n-k+1小，这样更容易理解
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>k</span> <span class=p>=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=nx>k</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>quickSelect</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>quickSelect</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>left</span> <span class=o>==</span> <span class=nx>right</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 选择基准值的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pivotIndex</span> <span class=o>:=</span> <span class=nf>partition</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>pivotIndex</span> <span class=o>==</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>pivotIndex</span> <span class=p>&lt;</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>quickSelect</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>pivotIndex</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>right</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>quickSelect</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>left</span><span class=p>,</span> <span class=nx>pivotIndex</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>partition</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 选择最右边的元素作为基准值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pivot</span> <span class=o>:=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=o>:=</span> <span class=nx>left</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>left</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>right</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=nx>pivot</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>right</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=复杂度分析>复杂度分析</h2><ul><li><p>时间复杂度：O(n)</p><ul><li>虽然最坏情况下是O(n²)，但平均时间复杂度是O(n)</li><li>这是因为每次partition后，我们只需要递归处理一半的数据</li></ul></li><li><p>空间复杂度：O(1)</p><ul><li>原地排序，只需要常数级别的额外空间</li></ul></li></ul><h2 id=示例>示例</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>输入</span><span class=p>:</span> <span class=nx>nums</span> <span class=p>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>4</span><span class=p>],</span> <span class=nx>k</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>输出</span><span class=p>:</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>解释</span><span class=p>:</span> <span class=nx>数组排序后为</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>]</span><span class=err>，</span><span class=nx>第2大的元素是5</span>
</span></span></code></pre></div><h2 id=注意事项>注意事项</h2><ol><li>这个解法会修改原数组，如果不想修改原数组，需要先复制一份</li><li>为了优化最坏情况，可以随机选择基准值</li><li>如果数组中有大量重复元素，可以使用三路快排的思想进行优化</li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/%E7%AE%97%E6%B3%95/>算法</a>
<a href=/tags/%E6%95%B0%E7%BB%84/>数组</a>
<a href=/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/>快速选择</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 zzj的笔记</section><section class=powerby><br><br><a href=https://beian.miit.gov.cn/ target=_blank>赣ICP备17015735号</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#题目描述>题目描述</a></li><li><a href=#解题思路>解题思路</a></li><li><a href=#图解示例>图解示例</a><ol><li><a href=#算法步骤说明>算法步骤说明</a></li><li><a href=#为什么是on时间复杂度>为什么是O(n)时间复杂度？</a></li></ol></li><li><a href=#代码实现>代码实现</a></li><li><a href=#复杂度分析>复杂度分析</a></li><li><a href=#示例>示例</a></li><li><a href=#注意事项>注意事项</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>